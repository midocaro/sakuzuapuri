<!DOCTYPE html>

<html lang="ja"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> <title>ä½œå›³ã‚¢ãƒ—ãƒªVer6.1</title> <style> /* --- CSS START --- */

/* === å…¨ä½“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ === */
body {
  margin: 0; padding: 0; font-family: Arial, sans-serif;
  display: flex; height: 100vh; height: 100dvh; 
  overflow: hidden; 
  /* æ“ä½œä¸èƒ½å›é¿ã®ãŸã‚ã€bodyå…¨ä½“ã®åˆ¶é™ã‚’ç·©å’Œ */
  touch-action: none; 
}

/* === å·¦å´ï¼šæ“ä½œãƒ‘ãƒãƒ«ï¼ˆå…¨ä½“æ ï¼‰ === */
#controls {
  width: 260px; background-color: #f8f9fa; 
  padding: 0;
  box-shadow: 2px 0 8px rgba(0,0,0,0.1); 
  overflow: hidden; 
  flex-shrink: 0; display: flex; flex-direction: column; 
  z-index: 10001; 
}

/* === å›ºå®šã‚¨ãƒªã‚¢ï¼ˆä¸Šéƒ¨ï¼‰ === */
#fixed-section {
  flex-shrink: 0; 
  padding: 15px 15px 10px 15px; 
  background-color: #f8f9fa;
  border-bottom: 2px solid #ddd; 
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  z-index: 10002;
  display: flex; flex-direction: column; gap: 10px;
}

/* === ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ï¼ˆä¸­å¤®ï¼‰ === */
#scrollable-section {
  flex-grow: 1; /* ä½™ã£ãŸã‚¹ãƒšãƒ¼ã‚¹ã‚’åŸ‹ã‚ã‚‹ */
  overflow-y: auto; /* ã“ã“ã ã‘ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹ */
  padding: 15px;
  display: flex; flex-direction: column; gap: 15px;
  touch-action: pan-y; 
}

/* === ãƒãƒŠãƒ¼ã‚¨ãƒªã‚¢ï¼ˆä¸‹éƒ¨å›ºå®šï¼‰ === */
#footer-banner {
  flex-shrink: 0;
  padding: 10px; text-align: center; 
  border-top: 1px solid #ddd; 
  background-color: #fafafa;
  z-index: 10002;
}

h3 {
  margin: 0 0 5px 0; font-size: 14px; color: #555; 
  font-weight: bold;
}
 
.section-title {
  font-size: 16px; color: #333; margin: 0 0 10px 0;
  border-bottom: 2px solid #ddd; padding-bottom: 5px;
}

/* ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ */
.radio-group { display: flex; flex-direction: column; gap: 10px; }
.radio-label {
  display: flex; align-items: center; cursor: pointer; padding: 8px;
  background: white; border-radius: 6px; border: 1px solid #ddd;
  transition: background 0.2s;
}
.radio-label:hover { background: #e9ecef; }
.radio-label input { margin-right: 10px; transform: scale(1.2); }

/* ãƒœã‚¿ãƒ³ */
.btn-group { display: flex; gap: 10px; }
.btn-group-vertical { display: flex; flex-direction: column; gap: 8px; }

.action-button {
  flex: 1; padding: 12px; border: none; background-color: #007bff;
  color: white; font-weight: bold; border-radius: 6px; cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background-color 0.2s;
  font-size: 14px; 
}
.action-button:active { transform: translateY(2px); box-shadow: none; }
#reset-button { background-color: #dc3545; }
 
/* å†ç”Ÿé–¢é€£ãƒœã‚¿ãƒ³ */
#start-replay-button { background-color: #6f42c1; width: 100%; }
#pause-button { background-color: #ffc107; color: black; }
#stop-button { background-color: #dc3545; }
 
/* è¦–ç‚¹æ“ä½œãƒœã‚¿ãƒ³ */
#reset-view-button { background-color: #6c757d; margin-bottom: 5px; }

/* å‹•ç‚¹ã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ */
#set-moving-button {
   background-color: #28a745; display: none; margin-top: 5px;
}
#set-moving-button.is-active {
   background-color: #dc3545; 
}
 
/* å‹•ç‚¹ç”¨è‰²å¡—ã‚Šã‚¹ã‚¤ãƒƒãƒ */
#moving-fill-container {
  display: none; align-items: center; justify-content: space-between;
  background: #fff; padding: 8px; border-radius: 6px; 
  border: 1px solid #ddd; margin-top: 5px;
}
 
/* ã‚°ãƒ©ãƒ•å…¥åŠ›ã‚¨ãƒªã‚¢ */
#graph-controls {
  display: none; 
  background: #e9ecef; padding: 8px; border-radius: 6px;
  flex-direction: column; gap: 6px;
}
.graph-label {
  font-size: 12px; font-weight: bold; color: #555; margin-bottom: 2px;
}
.graph-input-row {
  display: flex; align-items: center; 
  justify-content: space-between;
  gap: 1px;
  font-size: 10px; font-weight: bold; 
  white-space: nowrap;
}
.graph-input-row input {
  width: 24px; padding: 3px 1px; text-align: center; border: 1px solid #ccc; border-radius: 3px;
  font-size: 11px;
}
.graph-add-btn {
  padding: 4px 0; font-size: 12px; width: 100%; margin-top: 5px;
}

.practice-button { background-color: #17a2b8; text-align: left; padding-left: 15px; }
.levelup-button { background-color: #fd7e14; text-align: left; padding-left: 15px; }
#random-button { background-color: #ff9800; text-align: center; font-size: 16px; }
#answer-button { background-color: #e83e8c; text-align: center; margin-top: 5px; }
#retry-button { background-color: #20c997; }
#add-image-button { background-color: #28a745; color: white; width: 100%; }

/* ãƒ­ãƒƒã‚¯ãƒœã‚¿ãƒ³ */
#lock-button { background-color: #6c757d; display: none; color: white; }
#lock-button.is-locked { background-color: #dc3545; }

/* ä½œå›³ãƒ¢ãƒ¼ãƒ‰ãƒ»æ–¹çœ¼ç´™ã‚¹ã‚¤ãƒƒãƒå…±é€š */
.mode-switch-container {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px; background: #e2e6ea; border-radius: 6px; font-weight: bold; color: #333;
}
.switch { position: relative; display: inline-block; width: 50px; height: 26px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider {
  position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
  background-color: #ccc; transition: .4s; border-radius: 34px;
}
.slider:before {
  position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px;
  background-color: white; transition: .4s; border-radius: 50%;
}
input:checked + .slider { background-color: #28a745; }
input:checked + .slider:before { transform: translateX(24px); }

.color-group { display: flex; gap: 5px; }
.color-label {
  flex: 1; display: flex; justify-content: center; align-items: center;
  padding: 8px; cursor: pointer; background: white;
  border-radius: 6px; border: 1px solid #ddd; font-weight: bold;
}
.color-label:hover { background: #e9ecef; }
.color-label input { margin-right: 5px; transform: scale(1.2); }

.credit-line { margin-top: 20px; text-align: center; font-size: 12px; color: #888; font-weight: bold; }

#overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(255, 255, 255, 0); z-index: 10000; display: none; cursor: wait;
}

/* === å³å´ï¼šæç”»ã‚¨ãƒªã‚¢æ  === */
#drawing-area {
  flex-grow: 1; 
  background-color: #e0e0e0; 
  position: relative; overflow: hidden; touch-action: none; 
  cursor: crosshair; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¼ã‚½ãƒ«ã‚’æŒ‡å®š */
}

/* === å®Ÿéš›ã«å¤‰å½¢ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ç§»å‹•ï¼‰ã™ã‚‹ä¸­èº« === */
#canvas-content {
  position: absolute; top: 0; left: 0; 
  transform-origin: 0 0;
  background-color: #ffffff;
  box-shadow: 0 0 20px rgba(0,0,0,0.1); 
}
 
/* æ–¹çœ¼ç´™ï¼ˆã‚°ãƒªãƒƒãƒ‰ï¼‰ç”¨ã‚¯ãƒ©ã‚¹ï¼š25pxé–“éš” */
.grid-background {
  background-image: 
    linear-gradient(#e0e0e0 1px, transparent 1px),
    linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
  background-size: 25px 25px;
}

#main-canvas { 
  display: block; 
  position: absolute; top: 0; left: 0; z-index: 10; 
}
 
/* åº§æ¨™è»¸ãƒ»ã‚°ãƒ©ãƒ•ç”¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ */
#axis-canvas {
  display: none; 
  position: absolute; top: 0; left: 0; z-index: 5;
  pointer-events: none; 
}

/* â˜…å‹•ç‚¹ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰ */
#overlay-canvas {
  display: block;
  position: absolute; top: 0; left: 0; z-index: 15; /* Mainã®ä¸Šã€Compassã®ä¸‹ */
  pointer-events: none; /* ã‚¯ãƒªãƒƒã‚¯ã‚’é€é */
}

/* === ã‚³ãƒ³ãƒ‘ã‚¹UI === */
#compassContainer {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; display: none; z-index: 100;
}

#compassPivot {
  position: absolute; width: 10px; height: 10px; 
  background: rgba(220, 53, 69, 0.7); border: 1px solid white; border-radius: 50%; z-index: 110; 
  cursor: crosshair; pointer-events: auto; transform: translate(-50%, -50%); 
  box-shadow: 0 0 2px rgba(0,0,0,0.5);
}
#compassPivot::before { content: ''; position: absolute; top: -20px; left: -20px; right: -20px; bottom: -20px; }

#compassArm {
  position: absolute; height: 2px; background: rgba(100, 100, 100, 0.5);
  transform-origin: left center; z-index: 95; pointer-events: none; border-radius: 2px;
}
 
#pencilTip {
  position: absolute; width: 26px; height: 26px; background: #007bff; 
  border: 2px solid white; border-radius: 50%; right: 25px; top: -12px;       
  pointer-events: auto; cursor: ew-resize; z-index: 130;        
  box-shadow: 0 2px 5px rgba(0,0,0,0.4); transition: background-color 0.2s;
  display: flex; justify-content: center; align-items: center;
  color: white; font-weight: bold; font-size: 16px; line-height: 1;
}
#pencilTip::after { content: 'â†”'; padding-bottom: 2px; }
#pencilTip::before { content: ''; position: absolute; top: -25px; bottom: -25px; left: -25px; right: 25px; }
#pencilTip.locked { background: #dc3545; cursor: move; }
#pencilTip.locked::after { content: ''; }

#pencilDrawHandle {
  position: absolute; width: 40px; height: 40px; line-height: 40px;
  text-align: center; font-size: 24px; z-index: 120;
  pointer-events: auto; cursor: grabbing; background: white;
  border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  transition: transform 0.1s;
}
#pencilDrawHandle:active { background: #eef; }
 
/* === â˜…åˆ†åº¦å™¨UI === */
#protractorContainer {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; display: none; z-index: 90; /* ã‚³ãƒ³ãƒ‘ã‚¹ã‚ˆã‚Šä¸‹ */
}
 
#protractorBody {
  position: absolute; width: 340px; height: 170px; /* åŠå¾„170px */
  z-index: 91; pointer-events: auto; cursor: move;
  /* ä¸­å¿ƒç‚¹ã‚’åŸºæº–ã«å›è»¢ãƒ»ç§»å‹• */
  transform-origin: 50% 100%; 
}
 
#protractorCanvas {
  width: 100%; height: 100%; display: block;
}
 
#protractorRotateHandle {
  position: absolute; right: -20px; bottom: -20px; width: 40px; height: 40px;
  background: white; border-radius: 50%; border: 1px solid #ccc;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 95;
  display: flex; justify-content: center; align-items: center;
  font-size: 20px; cursor: grabbing; pointer-events: auto;
}
 
/* === ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« === */
.view-slider {
  position: absolute;
  z-index: 2000;
  opacity: 0.6;
  transition: opacity 0.2s;
  touch-action: pan-x pan-y; 
}
.view-slider:hover, .view-slider:active {
  opacity: 1.0;
}
 
/* æ¨ªã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆä¸‹ï¼‰ */
#slider-x {
  bottom: 60px; left: 50px; right: 50px;
  height: 20px; width: auto;
}
 
/* ç¸¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆå³ï¼‰ */
#slider-y {
  top: 50%; right: -100px;
  width: 250px; height: 20px;
  transform: rotate(90deg) translate(0, -50%);
  transform-origin: center;
}
 
@media (max-width: 600px) {
  #slider-x { left: 10px; right: 10px; bottom: 65px; }
  #slider-y { right: -110px; width: 250px; }
}

@media (min-width: 601px) and (max-width: 1024px) {
  #controls { width: 200px; padding: 0; }
  #fixed-section, #scrollable-section { padding: 10px; }
  h3 { font-size: 15px; }
}
@media (max-width: 600px) {
  #controls { width: 60px; padding: 0; }
  #fixed-section, #scrollable-section { padding: 5px; }
  h3, .radio-label span { display: none; }
  .radio-label { justify-content: center; }
  .radio-label input { margin: 0; transform: scale(1.5); }
  .btn-group { flex-direction: column; }
}

/* --- CSS END --- */
</style> </head> <body>

<div id="overlay"></div>

<div id="controls"> <div id="fixed-section"> <div class="control-group"> <h3>æ“ä½œ</h3> <div class="btn-group"> <button class="action-button" onclick="undoAction()">æˆ»ã‚‹</button> <button class="action-button" onclick="redoAction()">é€²ã‚€</button> <button class="action-button" id="reset-button" onclick="resetCanvas()">æ¶ˆå»</button> </div> </div>

  <div class="control-group">
    <h3>ç·šã®è‰²</h3>
    <div class="color-group">
      <label class="color-label" style="color: black;"><input type="radio" name="color" value="black" onchange="setColor(this.value)" checked> é»’</label>
      <label class="color-label" style="color: #dc3545;"><input type="radio" name="color" value="#dc3545" onchange="setColor(this.value)"> èµ¤</label>
      <label class="color-label" style="color: #007bff;"><input type="radio" name="color" value="#007bff" onchange="setColor(this.value)"> é’</label>
    </div>
  </div>
</div>

<div id="scrollable-section">
   
  <div class="control-group">
    <div style="margin-bottom: 0;">
      <button class="action-button" id="start-replay-button" onclick="startPlayback()">â–¶ ä½œå›³ã‚’å†ç”Ÿ</button>
      <div id="playback-controls" style="display:none; gap:5px; display:flex;">
         <button class="action-button" id="pause-button" onclick="togglePause()">â¸ ä¸€æ™‚åœæ­¢</button>
         <button class="action-button" id="stop-button" onclick="stopPlayback()">â¹ çµ‚äº†</button>
      </div>
    </div>
  </div>

  <div class="control-group">
    <h3 class="section-title">ãƒ„ãƒ¼ãƒ«</h3>
    <div class="radio-group">
      <label class="radio-label" id="label-point"><input type="radio" name="tool" value="point" onchange="setTool(this.value)" checked><span>ç‚¹</span></label>
      <label class="radio-label" id="label-moving_point"><input type="radio" name="tool" value="moving_point" onchange="setTool(this.value)"><span>å‹•ç‚¹</span></label>
      <label class="radio-label" id="label-line"><input type="radio" name="tool" value="line" onchange="setTool(this.value)"><span>ç‚¹ã¨ç‚¹ã‚’çµã¶</span></label>
      <label class="radio-label" id="label-ruler"><input type="radio" name="tool" value="ruler" onchange="setTool(this.value)"><span>ç›´ç·šï¼ˆå®šè¦ï¼‰</span></label>
      <label class="radio-label" id="label-compass"><input type="radio" name="tool" value="compass" onchange="setTool(this.value)"><span>ã‚³ãƒ³ãƒ‘ã‚¹</span></label>
      <label class="radio-label" id="label-protractor"><input type="radio" name="tool" value="protractor" onchange="setTool(this.value)"><span>åˆ†åº¦å™¨</span></label>
       
      <label class="radio-label" id="label-freehand"><input type="radio" name="tool" value="freehand" onchange="setTool(this.value)"><span>ãƒ•ãƒªãƒ¼ãƒãƒ³ãƒ‰</span></label>
      <label class="radio-label" id="label-eraser"><input type="radio" name="tool" value="eraser" onchange="setTool(this.value)"><span>æ¶ˆã—ã‚´ãƒ </span></label>
    </div>
    
    <button class="action-button" id="set-moving-button" onclick="toggleMovingSet()">ã‚»ãƒƒãƒˆï¼ˆç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã¸ï¼‰</button>
    
    <div id="moving-fill-container">
      <span style="font-size: 13px; font-weight: bold; color: #555;">è‰²ã‚’å¡—ã‚‹</span>
      <label class="switch" style="transform: scale(0.9);">
        <input type="checkbox" id="moving-fill-toggle" onchange="toggleMovingFill()" checked>
        <span class="slider"></span>
      </label>
    </div>
  </div>
   
  <div class="control-group">
    <button class="action-button" id="reset-view-button" onclick="resetView()">ğŸ” è¦–ç‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
  </div>

  <div class="control-group" id="compass-controls" style="display:none;">
    <h3 class="section-title">ã‚³ãƒ³ãƒ‘ã‚¹è¨­å®š</h3>
    <button class="action-button" id="lock-button" onclick="toggleCompassLock()">å¹…ã‚’ãƒ­ãƒƒã‚¯</button>
  </div>

  <div class="control-group">
    <div class="mode-switch-container">
      <span>ä½œå›³ãƒ¢ãƒ¼ãƒ‰</span>
      <label class="switch"><input type="checkbox" id="mode-toggle" onchange="toggleDrawingMode()"><span class="slider"></span></label>
    </div>
  </div>
   
  <div class="control-group">
    <div class="mode-switch-container">
      <span>æ–¹çœ¼ç´™</span>
      <label class="switch"><input type="checkbox" id="grid-toggle" onchange="toggleGrid()"><span class="slider"></span></label>
    </div>
  </div>
   
  <div class="control-group">
    <div class="mode-switch-container">
      <span>åº§æ¨™è»¸</span>
      <label class="switch"><input type="checkbox" id="axis-toggle" onchange="toggleAxis()"><span class="slider"></span></label>
    </div>
    
    <div id="graph-controls">
      <div class="graph-label">y = axÂ³ + bxÂ² + cx + d</div>
      <div class="graph-input-row">
        <input type="text" id="poly-a" value="0" placeholder="a" oninput="updatePolyPreview()">xÂ³+
        <input type="text" id="poly-b" value="0" placeholder="b" oninput="updatePolyPreview()">xÂ²+
        <input type="text" id="poly-c" value="0" placeholder="c" oninput="updatePolyPreview()">x+
        <input type="text" id="poly-d" value="0" placeholder="d" oninput="updatePolyPreview()">
      </div>
      <button class="action-button graph-add-btn" onclick="addPolyGraph()">ã‚°ãƒ©ãƒ•ã‚’è¿½åŠ </button>
      <button class="action-button" onclick="clearGraphs()" style="background-color: #dc3545; font-size: 11px; padding: 6px; width:100%; margin-top:5px;">ã‚°ãƒ©ãƒ•ã‚’å…¨æ¶ˆå»</button>
    </div>
  </div>
   
  <div class="control-group">
    <h3 class="section-title">ç”»åƒæŒ¿å…¥</h3>
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    <button class="action-button" id="add-image-button" onclick="document.getElementById('image-input').click()">ç”»åƒã‚’è¿½åŠ </button>
  </div>
   
  <div class="control-group">
    <h3 class="section-title" onclick="toggleSection('basic-practice-list', this)" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
      åŸºæœ¬ä½œå›³ã®ç·´ç¿’ <span>â–¼</span>
    </h3>
    <div id="basic-practice-list">
      <div class="btn-group-vertical">
        <button class="action-button practice-button" onclick="startPractice(1)">â‘ ç·šåˆ†ã®å‚ç›´äºŒç­‰åˆ†ç·š</button>
        <button class="action-button practice-button" onclick="startPractice(2)">â‘¡è§’ã®äºŒç­‰åˆ†ç·š</button>
        <button class="action-button practice-button" onclick="startPractice(3)">â‘¢ç›´ç·šä¸Šã®ç‚¹ã‚’é€šã‚‹å‚ç·š</button>
        <button class="action-button practice-button" onclick="startPractice(4)">â‘£ç›´ç·šä¸Šã«ãªã„ç‚¹ã‚’é€šã‚‹å‚ç·š</button>
        <button class="action-button" id="random-button" onclick="startRandomPractice()">ğŸ² ãƒ©ãƒ³ãƒ€ãƒ å‡ºé¡Œ</button>
      </div>
    </div>
  </div>
   
  <div class="control-group">
    <h3 class="section-title" onclick="toggleSection('levelup-practice-list', this)" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
      Lvã‚¢ãƒƒãƒ—ä½œå›³ç·´ç¿’ <span>â–¼</span>
    </h3>
    <div id="levelup-practice-list">
      <div class="btn-group-vertical">
        <button class="action-button levelup-button" onclick="startLevelUpBisector()">â‘ ç·šåˆ†ã®å‚ç›´äºŒç­‰åˆ†ç·š</button>
        <button class="action-button levelup-button" onclick="startLevelUpAngleBisector()">â‘¡è§’ã®äºŒç­‰åˆ†ç·š</button>
        <button class="action-button levelup-button" onclick="startLevelUpPerpOnLine()">â‘¢ç›´ç·šä¸Šã‚’é€šã‚‹å‚ç·š</button>
        <button class="action-button levelup-button" onclick="startLevelUpPerpOffLine()">â‘£ç›´ç·šä¸Šã«ãªã„ç‚¹ã‚’é€šã‚‹å‚ç·š</button>
      </div>
    </div>
  </div>

  <div class="control-group" id="problem-controls" style="display:none;">
     <h3 class="section-title">èª²é¡Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</h3>
     <div class="btn-group">
        <button class="action-button" id="retry-button" onclick="retryProblem()">ğŸ”„ ã‚‚ã†ä¸€åº¦</button>
        <button class="action-button" id="answer-button" onclick="showAnswer()" style="display:none;">ğŸ’¡ æ¨¡ç¯„è§£ç­”</button>
     </div>
  </div>

  <div class="credit-line">Produced by Komatsu</div>
  
</div>

<div id="footer-banner">
    <a href="[https://sites.google.com/view/k-system-lab/ãƒ›ãƒ¼ãƒ ](https://sites.google.com/view/k-system-lab/ãƒ›ãƒ¼ãƒ )" target="_blank" style="color:#007bff; text-decoration:none; font-weight:bold; font-size:12px;">
      ğŸ  K-System Lab<br>(ãƒ›ãƒ¼ãƒ ) ã«æˆ»ã‚‹
    </a>
</div>
</div>

<div id="drawing-area"> <div id="canvas-content"> <canvas id="axis-canvas"></canvas> <canvas id="main-canvas"></canvas> <canvas id="overlay-canvas"></canvas>

  <div id="compassContainer">
    <div id="compassPivot"></div>
    <div id="compassArm">
      <div id="pencilTip" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å¹…ã‚’å¤‰ãˆã‚‹"></div>
    </div>
    <div id="pencilDrawHandle" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å††ã‚’æã">âœï¸</div>
  </div>
   
  <div id="protractorContainer">
    <div id="protractorBody">
       <canvas id="protractorCanvas" width="340" height="170"></canvas>
       <div id="protractorRotateHandle">ğŸ”ƒ</div>
    </div>
  </div>
</div>
 
<input type="range" id="slider-x" class="view-slider" min="-2000" max="2000" value="0">
<input type="range" id="slider-y" class="view-slider" min="-2000" max="2000" value="0">
</div>

<script> /* --- JS START --- */

// â– â– â–  ã‚¨ãƒ©ãƒ¼æ¤œçŸ¥æ©Ÿèƒ½ï¼ˆã‚¢ãƒ—ãƒªãŒå‡çµã—ãŸç†ç”±ã‚’ç”»é¢ã«å‡ºã™ï¼‰ â– â– â– 
window.onerror = function(msg, url, line) {
   alert(&quot;ã€ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿã€‘\n&quot; + msg + &quot;\nè¡Œç•ªå·: &quot; + line + &quot;\n\nã“ã®ç”»é¢ãŒå‡ºãŸã‚‰ã€ã‚³ãƒ¼ãƒ‰ã®è²¼ã‚Šä»˜ã‘ãƒŸã‚¹ã‚„ãƒ–ãƒ©ã‚¦ã‚¶ã®ç›¸æ€§å•é¡Œã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚&quot;);
   return false;
};

const canvas = document.getElementById(&#39;main-canvas&#39;);
const ctx = canvas.getContext(&#39;2d&#39;);
 
const axisCanvas = document.getElementById(&#39;axis-canvas&#39;);
const axisCtx = axisCanvas.getContext(&#39;2d&#39;);
 
// â˜…å‹•ç‚¹ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
const overlayCanvas = document.getElementById(&#39;overlay-canvas&#39;);
const overlayCtx = overlayCanvas.getContext(&#39;2d&#39;);
 
const drawingArea = document.getElementById(&#39;drawing-area&#39;);
const canvasContent = document.getElementById(&#39;canvas-content&#39;);
const imageInput = document.getElementById(&#39;image-input&#39;);
const overlay = document.getElementById(&#39;overlay&#39;);
 
// ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¦ç´ å–å¾—
const sliderX = document.getElementById(&#39;slider-x&#39;);
const sliderY = document.getElementById(&#39;slider-y&#39;);

let view = { scale: 1, x: 0, y: 0 };
let isPanning = false;
let startPan = { x: 0, y: 0 };
let initialPinchDist = 0;
let initialScale = 1;
 
let currentTool = &#39;point&#39;;
let currentColor = &#39;black&#39;; 
let isDrawing = false;
let lineStartPoint = null; 
let history = []; 
let redoStack = [];
let currentProblem = null; 
 
let movingPoints = []; 
let isMovingPointSet = false; 
let dragMovingPointIndex = -1; 
let isMovingFillMode = true;
 
// ã‚°ãƒ©ãƒ•ç®¡ç†ç”¨
let activeGraphs = [];
let previewGraph = null; 
const graphColors = [&#39;#007bff&#39;, &#39;#28a745&#39;, &#39;#fd7e14&#39;, &#39;#6610f2&#39;, &#39;#e83e8c&#39;];

// å†ç”Ÿç”¨
let playbackTimer = null;
let playbackStep = 0;
let isPaused = false;

// ã‚³ãƒ³ãƒ‘ã‚¹
let compass = {
  isDragging: false, dragTarget: null, 
  pivotX: 200, pivotY: 200, radius: 100, angle: 0, 
  locked: false, centerDrawn: false
};
 
// â˜…åˆ†åº¦å™¨
let protractor = {
  isDragging: false, dragTarget: null,
  x: 300, y: 300, angle: 0, 
  width: 340, height: 170
};

const compassContainer = document.getElementById(&#39;compassContainer&#39;);
const compassPivot = document.getElementById(&#39;compassPivot&#39;);
const compassArm = document.getElementById(&#39;compassArm&#39;);
const pencilDrawHandle = document.getElementById(&#39;pencilDrawHandle&#39;);
const pencilTip = document.getElementById(&#39;pencilTip&#39;);
const lockButton = document.getElementById(&#39;lock-button&#39;);
const compassControls = document.getElementById(&#39;compass-controls&#39;);
 
// â˜…åˆ†åº¦å™¨ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆ
const protractorContainer = document.getElementById(&#39;protractorContainer&#39;);
const protractorBody = document.getElementById(&#39;protractorBody&#39;);
const protractorCanvas = document.getElementById(&#39;protractorCanvas&#39;);
const protractorRotateHandle = document.getElementById(&#39;protractorRotateHandle&#39;);
 
const problemControls = document.getElementById(&#39;problem-controls&#39;);
const answerButton = document.getElementById(&#39;answer-button&#39;);
const retryButton = document.getElementById(&#39;retry-button&#39;);
 
const setMovingButton = document.getElementById(&#39;set-moving-button&#39;);
const movingFillContainer = document.getElementById(&#39;moving-fill-container&#39;);
const graphControls = document.getElementById(&#39;graph-controls&#39;);

const startReplayBtn = document.getElementById(&#39;start-replay-button&#39;);
const playbackControls = document.getElementById(&#39;playback-controls&#39;);
const pauseBtn = document.getElementById(&#39;pause-button&#39;);

const labels = {
  point: document.getElementById(&#39;label-point&#39;),
  moving_point: document.getElementById(&#39;label-moving_point&#39;),
  line: document.getElementById(&#39;label-line&#39;),
  ruler: document.getElementById(&#39;label-ruler&#39;),
  compass: document.getElementById(&#39;label-compass&#39;),
  protractor: document.getElementById(&#39;label-protractor&#39;), 
  freehand: document.getElementById(&#39;label-freehand&#39;),
  eraser: document.getElementById(&#39;label-eraser&#39;)
};

window.addEventListener(&#39;load&#39;, () =&gt; {
    try {
        initCanvasSize(); saveState(); updateCompassUI(); 
        initProtractor(); updateProtractorUI(); 
        addToolListeners(); setupImagePaste(); 
        drawingArea.addEventListener(&#39;wheel&#39;, handleWheel, { passive: false });
        window.addEventListener(&#39;resize&#39;, resizeCanvas);
        
        sliderX.addEventListener(&#39;input&#39;, handleSliderChange);
        sliderY.addEventListener(&#39;input&#39;, handleSliderChange);
    } catch(e) {
        alert(&quot;èµ·å‹•æ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: &quot; + e.message);
    }
});
 
// â˜…åˆ†åº¦å™¨ã®æç”»ï¼ˆä¸€åº¦ã ã‘å®Ÿè¡Œï¼‰
function initProtractor() {
   const pCtx = protractorCanvas.getContext(&#39;2d&#39;);
   const w = protractorCanvas.width;
   const h = protractorCanvas.height;
   const cx = w / 2;
   const cy = h; // åº•è¾ºã®ä¸­å¤®
   const r = h - 5; // ä½™ç™½
   
   pCtx.clearRect(0, 0, w, h);
   
   // åŠå††ã®èƒŒæ™¯
   pCtx.beginPath();
   pCtx.arc(cx, cy, r, Math.PI, 0);
   pCtx.lineTo(cx, cy);
   pCtx.closePath();
   pCtx.fillStyle = &quot;rgba(255, 255, 255, 0.6)&quot;; // åŠé€æ˜
   pCtx.fill();
   pCtx.lineWidth = 2;
   pCtx.strokeStyle = &quot;#333&quot;;
   pCtx.stroke();
   
   // ä¸­å¿ƒç‚¹
   pCtx.beginPath();
   pCtx.arc(cx, cy, 3, 0, Math.PI*2);
   pCtx.fillStyle = &quot;red&quot;;
   pCtx.fill();
   
   // ç›®ç››ã‚Š
   pCtx.textAlign = &quot;center&quot;;
   pCtx.textBaseline = &quot;middle&quot;;
   pCtx.fillStyle = &quot;black&quot;;
   
   for(let i = 0; i &lt;= 180; i++) {
      const rad = (Math.PI / 180) * (180 - i);
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      
      let len = 5;
      if (i % 10 === 0) len = 15;
      else if (i % 5 === 0) len = 10;
      
      // å¤–å´ã®ç·š
      pCtx.beginPath();
      pCtx.moveTo(cx + (r - len) * cos, cy - (r - len) * sin);
      pCtx.lineTo(cx + r * cos, cy - r * sin);
      pCtx.stroke();
      
      // æ•°å­—
      if (i % 10 === 0) {
         // å¤–å´ã®æ•°å­— (0 -&gt; 180)
         pCtx.font = &quot;bold 12px Arial&quot;;
         pCtx.fillText(i, cx + (r - 28) * cos, cy - (r - 28) * sin);
         
         // å†…å´ã®æ•°å­— (180 -&gt; 0)
         pCtx.font = &quot;10px Arial&quot;;
         pCtx.fillStyle = &quot;#555&quot;;
         pCtx.fillText(180 - i, cx + (r - 45) * cos, cy - (r - 45) * sin);
         pCtx.fillStyle = &quot;black&quot;;
      }
   }
}
 
function updateProtractorUI() {
   const left = protractor.x - (protractor.width / 2);
   const top = protractor.y - protractor.height;
   
   protractorBody.style.left = left + &#39;px&#39;;
   protractorBody.style.top = top + &#39;px&#39;;
   protractorBody.style.transform = `rotate(${protractor.angle * 180 / Math.PI}deg)`;
}

function toggleSection(id, element) {
  const content = document.getElementById(id);
  const icon = element.querySelector(&#39;span&#39;);
  if (content.style.display === &#39;none&#39;) {
    content.style.display = &#39;block&#39;;
    icon.innerText = &#39;â–¼&#39;;
  } else {
    content.style.display = &#39;none&#39;;
    icon.innerText = &#39;â–²&#39;;
  }
}

function initCanvasSize() {
  const rect = drawingArea.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  axisCanvas.width = rect.width;
  axisCanvas.height = rect.height;
  overlayCanvas.width = rect.width;
  overlayCanvas.height = rect.height;
   
  canvasContent.style.width = rect.width + &#39;px&#39;;
  canvasContent.style.height = rect.height + &#39;px&#39;;
   
  compass.pivotX = rect.width / 2;
  compass.pivotY = rect.height / 2;
   
  // åˆ†åº¦å™¨ã‚‚ä¸­å¤®ã¸
  protractor.x = rect.width / 2;
  protractor.y = rect.height / 2;
   
  if(document.getElementById(&#39;axis-toggle&#39;).checked) {
      drawAxis();
  }
   
  if (history.length &gt; 0) restoreState(history[history.length - 1]);
}
 
function resizeCanvas() {
   if (history.length &gt; 0) {
      const rect = drawingArea.getBoundingClientRect();
      
      canvas.width = rect.width;
      canvas.height = rect.height;
      axisCanvas.width = rect.width;
      axisCanvas.height = rect.height;
      overlayCanvas.width = rect.width;
      overlayCanvas.height = rect.height;
      
      canvasContent.style.width = rect.width + &#39;px&#39;;
      canvasContent.style.height = rect.height + &#39;px&#39;;

      restoreState(history[history.length - 1]);
      drawMovingPoints();
      
      if(document.getElementById(&#39;axis-toggle&#39;).checked) {
         drawAxis();
      }
   } else {
      initCanvasSize();
   }
}

function handleSliderChange() {
   view.x = -parseInt(sliderX.value, 10);
   view.y = -parseInt(sliderY.value, 10);
   updateTransform();
}

function updateTransform() {
  canvasContent.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
  sliderX.value = -view.x;
  sliderY.value = -view.y;
}
 
function resetView() { 
   view = { scale: 1, x: 0, y: 0 }; 
   updateTransform(); 
}

function handleWheel(e) {
  if (!e.ctrlKey &amp;&amp; !e.metaKey) { e.preventDefault(); }
  const rect = drawingArea.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const zoomFactor = e.deltaY &lt; 0 ? 1.1 : 0.9;
  const newScale = view.scale * zoomFactor;
  if (newScale &lt; 0.5 || newScale &gt; 5.0) return;
  view.x = mouseX - (mouseX - view.x) * (newScale / view.scale);
  view.y = mouseY - (mouseY - view.y) * (newScale / view.scale);
  view.scale = newScale;
  updateTransform();
}

function getEventPos(e) {
  const rect = drawingArea.getBoundingClientRect();
  let cx, cy;
  if (e.touches &amp;&amp; e.touches.length &gt; 0) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; } 
  else { cx = e.clientX; cy = e.clientY; }
  const screenX = cx - rect.left;
  const screenY = cy - rect.top;
  return { x: (screenX - view.x) / view.scale, y: (screenY - view.y) / view.scale };
}

function setTool(newTool) {
  if (currentTool === &#39;moving_point&#39; &amp;&amp; newTool !== &#39;moving_point&#39;) {
     isMovingPointSet = false;
     dragMovingPointIndex = -1;
     updateMovingButtonUI(); 
  }
   
  currentTool = newTool;
  lineStartPoint = null;
   
  if (currentTool === &#39;moving_point&#39;) {
    setMovingButton.style.display = &#39;block&#39;;
    movingFillContainer.style.display = &#39;flex&#39;; 
    if (movingPoints.length &gt; 0) {
       isMovingPointSet = true;
    } else {
       isMovingPointSet = false;
    }
    updateMovingButtonUI();
    drawMovingPoints();
  } else {
    setMovingButton.style.display = &#39;none&#39;;
    movingFillContainer.style.display = &#39;none&#39;; 
  }
   
  // ã‚³ãƒ³ãƒ‘ã‚¹
  if (currentTool === &#39;compass&#39;) {
    compassContainer.style.display = &#39;block&#39;; compassControls.style.display = &#39;block&#39;; lockButton.style.display = &#39;block&#39;;
    compass.radius = 100; compass.locked = false; updateLockUI(); updateCompassUI();
  } else {
    compassContainer.style.display = &#39;none&#39;; compassControls.style.display = &#39;none&#39;;
  }
   
  // â˜…åˆ†åº¦å™¨
  if (currentTool === &#39;protractor&#39;) {
     protractorContainer.style.display = &#39;block&#39;;
     updateProtractorUI();
  } else {
     protractorContainer.style.display = &#39;none&#39;;
  }
   
  updateCursor();
}

function toggleMovingSet() {
  isMovingPointSet = !isMovingPointSet;
  updateMovingButtonUI();
}
 
function toggleMovingFill() {
  isMovingFillMode = document.getElementById(&#39;moving-fill-toggle&#39;).checked;
  drawMovingPoints();
}
 
function toggleGrid() {
  const isGrid = document.getElementById(&#39;grid-toggle&#39;).checked;
  if (isGrid) {
    canvasContent.classList.add(&#39;grid-background&#39;);
  } else {
    canvasContent.classList.remove(&#39;grid-background&#39;);
  }
}
 
function toggleAxis() {
  const isAxis = document.getElementById(&#39;axis-toggle&#39;).checked;
  if (isAxis) {
    axisCanvas.style.display = &#39;block&#39;;
    graphControls.style.display = &#39;flex&#39;; 
    drawAxis(); 
  } else {
    axisCanvas.style.display = &#39;none&#39;;
    graphControls.style.display = &#39;none&#39;;
  }
}
 
function parseMathInput(val) {
  if (typeof val !== &#39;string&#39;) return parseFloat(val) || 0;
  val = val.trim();
  if (val === &#39;&#39;) return 0;
  if (val.includes(&#39;/&#39;)) {
    const parts = val.split(&#39;/&#39;);
    if (parts.length === 2) {
      const numerator = parseFloat(parts[0]);
      const denominator = parseFloat(parts[1]);
      if (!isNaN(numerator) &amp;&amp; !isNaN(denominator) &amp;&amp; denominator !== 0) {
        return numerator / denominator;
      }
    }
  }
  return parseFloat(val) || 0;
}
 
function updatePolyPreview() {
  const a = parseMathInput(document.getElementById(&#39;poly-a&#39;).value);
  const b = parseMathInput(document.getElementById(&#39;poly-b&#39;).value);
  const c = parseMathInput(document.getElementById(&#39;poly-c&#39;).value);
  const d = parseMathInput(document.getElementById(&#39;poly-d&#39;).value);
  previewGraph = { type: &#39;poly&#39;, a:a, b:b, c:c, d:d, color: &#39;#999&#39;, isPreview: true };
  drawAxis();
}
 
function addPolyGraph() {
  const a = parseMathInput(document.getElementById(&#39;poly-a&#39;).value);
  const b = parseMathInput(document.getElementById(&#39;poly-b&#39;).value);
  const c = parseMathInput(document.getElementById(&#39;poly-c&#39;).value);
  const d = parseMathInput(document.getElementById(&#39;poly-d&#39;).value);
  const color = graphColors[activeGraphs.length % graphColors.length];
  activeGraphs.push({ type: &#39;poly&#39;, a:a, b:b, c:c, d:d, color: color });
  previewGraph = null;
  drawAxis();
}
 
function clearGraphs() {
  activeGraphs = [];
  previewGraph = null;
  drawAxis();
}
 
function drawAxis() {
  const w = axisCanvas.width;
  const h = axisCanvas.height;
  const cx = w / 2;
  const cy = h / 2;
  const gridSize = 25; 
   
  axisCtx.clearRect(0, 0, w, h);
   
  axisCtx.strokeStyle = &quot;#e0e0e0&quot;;
  axisCtx.lineWidth = 1;
  axisCtx.beginPath();
  for (let x = cx; x &lt; w; x += gridSize) { axisCtx.moveTo(x, 0); axisCtx.lineTo(x, h); }
  for (let x = cx; x &gt; 0; x -= gridSize) { axisCtx.moveTo(x, 0); axisCtx.lineTo(x, h); }
  for (let y = cy; y &lt; h; y += gridSize) { axisCtx.moveTo(0, y); axisCtx.lineTo(w, y); }
  for (let y = cy; y &gt; 0; y -= gridSize) { axisCtx.moveTo(0, y); axisCtx.lineTo(w, y); }
  axisCtx.stroke();
   
  axisCtx.strokeStyle = &quot;#444&quot;;
  axisCtx.lineWidth = 1.5;
  axisCtx.fillStyle = &quot;#444&quot;;
  axisCtx.font = &quot;italic 16px Arial&quot;;
   
  axisCtx.beginPath(); axisCtx.moveTo(0, cy); axisCtx.lineTo(w, cy); axisCtx.stroke();
  axisCtx.beginPath(); axisCtx.moveTo(w, cy); axisCtx.lineTo(w - 10, cy - 5); axisCtx.lineTo(w - 10, cy + 5); axisCtx.fill();
  axisCtx.fillText(&quot;x&quot;, w - 20, cy + 20);
   
  axisCtx.beginPath(); axisCtx.moveTo(cx, 0); axisCtx.lineTo(cx, h); axisCtx.stroke();
  axisCtx.beginPath(); axisCtx.moveTo(cx, 0); axisCtx.lineTo(cx - 5, 10); axisCtx.lineTo(cx + 5, 10); axisCtx.fill();
  axisCtx.fillText(&quot;y&quot;, cx - 20, 15);
  axisCtx.fillText(&quot;O&quot;, cx - 15, cy + 20);
   
  drawGraphs(cx, cy, gridSize);
}
 
function drawGraphs(cx, cy, unit) {
  activeGraphs.forEach(g =&gt; drawSingleGraph(g, cx, cy, unit));
  if (previewGraph) {
     drawSingleGraph(previewGraph, cx, cy, unit);
  }
}
 
function drawSingleGraph(g, cx, cy, unit) {
  axisCtx.beginPath();
  axisCtx.strokeStyle = g.color;
  axisCtx.lineWidth = 2;
   
  if (g.isPreview) axisCtx.setLineDash([5, 5]); 
  else axisCtx.setLineDash([]); 
   
  if (g.type === &#39;poly&#39;) {
    let first = true;
    for(let px = 0; px &lt;= axisCanvas.width; px += 2) {
       const mx = (px - cx) / unit;
       const my = g.a * Math.pow(mx, 3) + g.b * Math.pow(mx, 2) + g.c * mx + g.d;
       const py = cy - my * unit;
       
       if(first) { axisCtx.moveTo(px, py); first = false; }
       else { axisCtx.lineTo(px, py); }
    }
  }
  axisCtx.stroke();
  axisCtx.setLineDash([]); 
}

function updateMovingButtonUI() {
  if (isMovingPointSet) {
    setMovingButton.textContent = &quot;å‹•ç‚¹ã‚’è§£é™¤&quot;;
    setMovingButton.classList.add(&#39;is-active&#39;);
  } else {
    setMovingButton.textContent = &quot;ã‚»ãƒƒãƒˆï¼ˆç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã¸ï¼‰&quot;;
    setMovingButton.classList.remove(&#39;is-active&#39;);
  }
}

function setColor(color) { currentColor = color; }
function updateCursor() { canvas.style.cursor = (currentTool === &#39;freehand&#39; || currentTool === &#39;point&#39; || currentTool === &#39;moving_point&#39; || currentTool === &#39;eraser&#39;) ? &#39;crosshair&#39; : &#39;default&#39;; }

// â˜…â˜…â˜… ä½œå›³ãƒ¢ãƒ¼ãƒ‰æ™‚ã«åˆ†åº¦å™¨ã‚‚éš ã™ã‚ˆã†ã«ä¿®æ­£ â˜…â˜…â˜…
function toggleDrawingMode() {
  const isMode = document.getElementById(&#39;mode-toggle&#39;).checked;
  if (isMode) {
    labels.point.style.display = &#39;none&#39;; 
    labels.moving_point.style.display = &#39;none&#39;;
    labels.line.style.display = &#39;none&#39;; 
    labels.freehand.style.display = &#39;none&#39;;
    labels.eraser.style.display = &#39;none&#39;; 
    labels.protractor.style.display = &#39;none&#39;; // â˜…ã“ã“ã‚’è¿½åŠ ï¼ˆåˆ†åº¦å™¨ã‚’éš ã™ï¼‰

    // ã‚‚ã—éš ã•ã‚Œã‚‹ãƒ„ãƒ¼ãƒ«ã‚’é¸æŠä¸­ã ã£ãŸå ´åˆã€å®šè¦ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
    // â˜…é…åˆ—ã« &#39;protractor&#39; ã‚’è¿½åŠ ã—ã¾ã—ãŸ
    if ([&#39;point&#39;,&#39;moving_point&#39;,&#39;line&#39;,&#39;freehand&#39;,&#39;eraser&#39;, &#39;protractor&#39;].includes(currentTool)) {
      document.querySelector(&#39;input[value=&quot;ruler&quot;]&#39;).checked = true; setTool(&#39;ruler&#39;);
    }
  } else {
    labels.point.style.display = &#39;flex&#39;; 
    labels.moving_point.style.display = &#39;flex&#39;;
    labels.line.style.display = &#39;flex&#39;; 
    labels.freehand.style.display = &#39;flex&#39;;
    labels.eraser.style.display = &#39;flex&#39;;
    labels.protractor.style.display = &#39;flex&#39;; // â˜…ã“ã“ã‚’è¿½åŠ ï¼ˆåˆ†åº¦å™¨ã‚’è¡¨ç¤ºï¼‰
  }
}

function toggleCompassLock() { compass.locked = !compass.locked; updateLockUI(); }
function updateLockUI() {
  if (compass.locked) {
    lockButton.classList.add(&#39;is-locked&#39;); lockButton.textContent = &#39;ãƒ­ãƒƒã‚¯è§£é™¤&#39;; 
    pencilTip.classList.add(&#39;locked&#39;); pencilTip.title = &quot;è§’åº¦ã®ã¿èª¿æ•´ï¼ˆæç”»ãªã—ï¼‰&quot;;
  } else {
    lockButton.classList.remove(&#39;is-locked&#39;); lockButton.textContent = &#39;å¹…ã‚’ãƒ­ãƒƒã‚¯&#39;; 
    pencilTip.classList.remove(&#39;locked&#39;); pencilTip.title = &quot;å¹…ã¨è§’åº¦ã‚’èª¿æ•´&quot;;
  }
}

function startPlayback() {
  if (history.length &lt;= 1) return;
  startReplayBtn.style.display = &#39;none&#39;;
  playbackControls.style.display = &#39;flex&#39;;
  overlay.style.display = &#39;block&#39;; 
  playbackStep = 0; isPaused = false; pauseBtn.textContent = &#39;â¸ ä¸€æ™‚åœæ­¢&#39;;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  loopFunction();
}
function loopFunction() {
  if (isPaused) return;
  if (playbackStep &lt; history.length) {
    restoreState(history[playbackStep]);
    playbackStep++;
    playbackTimer = setTimeout(loopFunction, 800); 
  } else {
    playbackTimer = setTimeout(() =&gt; {
       if (isPaused) return;
       playbackStep = 0;
       ctx.clearRect(0, 0, canvas.width, canvas.height); 
       playbackTimer = setTimeout(loopFunction, 500); 
    }, 2000); 
  }
}
function togglePause() {
  if (isPaused) { isPaused = false; pauseBtn.textContent = &#39;â¸ ä¸€æ™‚åœæ­¢&#39;; loopFunction(); } 
  else { isPaused = true; pauseBtn.textContent = &#39;â–¶ å†é–‹&#39;; clearTimeout(playbackTimer); }
}
function stopPlayback() {
  clearTimeout(playbackTimer); isPaused = false;
  restoreState(history[history.length - 1]);
  overlay.style.display = &#39;none&#39;; playbackControls.style.display = &#39;none&#39;; startReplayBtn.style.display = &#39;block&#39;;
}

function startRandomPractice() { startPractice(Math.floor(Math.random() * 4) + 1); }
function retryProblem() {
  if (!currentProblem) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  history = []; redoStack = []; lineStartPoint = null;
  if (currentProblem.type.toString().startsWith(&#39;levelup_&#39;)) drawLevelUpProblem(currentProblem);
  else drawProblem(currentProblem);
  saveState();
}
 
function generateCompactTriangle(w, h) {
  const cx = w / 2, cy = h / 2;
  const radius = 120 + Math.random() * 80;
  const angleA = Math.random() * Math.PI * 2;
  const Ax = cx + radius * Math.cos(angleA), Ay = cy + radius * Math.sin(angleA);
  const angleB = angleA + (Math.PI * 2 / 3) + (Math.random() * 0.5 - 0.25);
  const Bx = cx + radius * Math.cos(angleB), By = cy + radius * Math.sin(angleB);
  const angleC = angleA + (Math.PI * 4 / 3) + (Math.random() * 0.5 - 0.25);
  const Cx = cx + radius * Math.cos(angleC), Cy = cy + radius * Math.sin(angleC);
  return { A: { x: Ax, y: Ay }, B: { x: Bx, y: By }, C: { x: Cx, y: Cy } };
}
 
// â˜…â˜…â˜… Lvã‚¢ãƒƒãƒ—å•é¡Œ1ï¼šä¸‰è§’å½¢ã®å‚ç›´äºŒç­‰åˆ†ç·šï¼ˆã€Œç·šåˆ†ã€ã«ä¿®æ­£ï¼‰ â˜…â˜…â˜…
function startLevelUpBisector() {
  setupLevelUpProblem();
  const tri = generateCompactTriangle(canvas.width, canvas.height);
  const questions = [
    { text: &quot;ç·šåˆ†ABã®å‚ç›´äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, p1: tri.A, p2: tri.B },
    { text: &quot;ç·šåˆ†BCã®å‚ç›´äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, p1: tri.B, p2: tri.C },
    { text: &quot;ç·šåˆ†CAã®å‚ç›´äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, p1: tri.C, p2: tri.A }
  ];
  const selected = questions[Math.floor(Math.random() * 3)];
  currentProblem = { type: &#39;levelup_bisector&#39;, A: tri.A, B: tri.B, C: tri.C, questionText: selected.text, targetP1: selected.p1, targetP2: selected.p2 };
  drawLevelUpProblem(currentProblem); saveState();
}
 
function startLevelUpAngleBisector() {
  setupLevelUpProblem();
  const tri = generateCompactTriangle(canvas.width, canvas.height);
  const questions = [
    { text: &quot;âˆ BACã®äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, O: tri.A, arm1: tri.B, arm2: tri.C },
    { text: &quot;âˆ ABCã®äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, O: tri.B, arm1: tri.A, arm2: tri.C },
    { text: &quot;âˆ BCAã®äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, O: tri.C, arm1: tri.A, arm2: tri.B }
  ];
  const selected = questions[Math.floor(Math.random() * 3)];
  currentProblem = { type: &#39;levelup_angle_bisector&#39;, A: tri.A, B: tri.B, C: tri.C, questionText: selected.text, targetO: selected.O, targetArm1: selected.arm1, targetArm2: selected.arm2 };
  drawLevelUpProblem(currentProblem); saveState();
}
function startLevelUpPerpOnLine() {
  setupLevelUpProblem();
  const tri = generateCompactTriangle(canvas.width, canvas.height);
  const sides = [{ p1: tri.A, p2: tri.B }, { p1: tri.B, p2: tri.C }, { p1: tri.C, p2: tri.A }];
  const s = sides[Math.floor(Math.random() * 3)];
  const t = 0.3 + Math.random() * 0.4;
  const P = { x: s.p1.x + (s.p2.x - s.p1.x) * t, y: s.p1.y + (s.p2.y - s.p1.y) * t };
  const angle = Math.atan2(s.p2.y - s.p1.y, s.p2.x - s.p1.x);
  currentProblem = { type: &#39;levelup_perp_online&#39;, A: tri.A, B: tri.B, C: tri.C, P: P, lineAngle: angle, questionText: &quot;ç‚¹Pã®å‚ç·šã‚’ä½œå›³ã—ãªã•ã„&quot; };
  drawLevelUpProblem(currentProblem); saveState();
}
// â˜…â˜…â˜… Lvã‚¢ãƒƒãƒ—å•é¡Œ4ï¼šç›´ç·šä¸Šã«ãªã„ç‚¹ã‚’é€šã‚‹å‚ç·š (æ–°è¦) â˜…â˜…â˜…
function startLevelUpPerpOffLine() {
  setupLevelUpProblem();
  const tri = generateCompactTriangle(canvas.width, canvas.height);
  const q = [
    { text: &quot;ç‚¹Aã‹ã‚‰ç›´ç·šBCã«å‚ç·šã‚’å¼•ããªã•ã„&quot;, P: tri.A, s: tri.B, e: tri.C },
    { text: &quot;ç‚¹Bã‹ã‚‰ç›´ç·šACã«å‚ç·šã‚’å¼•ããªã•ã„&quot;, P: tri.B, s: tri.A, e: tri.C },
    { text: &quot;ç‚¹Cã‹ã‚‰ç›´ç·šABã«å‚ç·šã‚’å¼•ããªã•ã„&quot;, P: tri.C, s: tri.A, e: tri.B }
  ];
  const selected = q[Math.floor(Math.random() * 3)];
  const angle = Math.atan2(selected.e.y - selected.s.y, selected.e.x - selected.s.x);
  currentProblem = { type: &#39;levelup_perp_offline&#39;, A: tri.A, B: tri.B, C: tri.C, P: selected.P, lineP: selected.s, lineAngle: angle, questionText: selected.text };
  drawLevelUpProblem(currentProblem); saveState();
}
 
function setupLevelUpProblem() {
  ctx.clearRect(0, 0, canvas.width, canvas.height); history = []; redoStack = []; lineStartPoint = null;
  problemControls.style.display = &#39;block&#39;; answerButton.style.display = &#39;block&#39;; retryButton.style.display = &#39;block&#39;;
}
function drawLevelUpProblem(p) {
  const savedColor = currentColor; currentColor = &#39;black&#39;; ctx.fillStyle = &quot;black&quot;; ctx.font = &quot;20px Arial&quot;;
  ctx.fillText(p.questionText, 30, 50);
  drawLine(p.A.x, p.A.y, p.B.x, p.B.y, &#39;line&#39;); drawLine(p.B.x, p.B.y, p.C.x, p.C.y, &#39;line&#39;); drawLine(p.C.x, p.C.y, p.A.x, p.A.y, &#39;line&#39;);
  drawPoint(p.A.x, p.A.y); drawPoint(p.B.x, p.B.y); drawPoint(p.C.x, p.C.y);
  ctx.fillStyle = &quot;black&quot;; ctx.font = &quot;bold 24px Arial&quot;;
  ctx.fillText(&quot;A&quot;, p.A.x-10, p.A.y-15); ctx.fillText(&quot;B&quot;, p.B.x-25, p.B.y+10); ctx.fillText(&quot;C&quot;, p.C.x+10, p.C.y+10);
  if (p.type === &#39;levelup_perp_online&#39;) { drawPoint(p.P.x, p.P.y); ctx.fillText(&quot;P&quot;, p.P.x+15, p.P.y-15); }
  currentColor = savedColor;
}

function startPractice(type) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  history = []; redoStack = []; lineStartPoint = null;
  const w = canvas.width, h = canvas.height;
  let problem = { type: type };
  if (type === 1) { 
    let A, B, valid=false;
    while(!valid) {
         A={x:60+Math.random()*(w-120), y:80+Math.random()*(h-140)};
         const ang=Math.random()*Math.PI*2, len=150+Math.random()*200;
         B={x:A.x+len*Math.cos(ang), y:A.y+len*Math.sin(ang)};
         if(B.x&gt;60 &amp;&amp; B.x&lt;w-60 &amp;&amp; B.y&gt;80 &amp;&amp; B.y&lt;h-60) valid=true;
    }
    problem.A=A; problem.B=B;
  } else if (type === 2) { 
    problem.O = {x:w/2+(Math.random()-0.5)*100, y:h/2+(Math.random()-0.5)*100};
    problem.baseAngle=Math.random()*Math.PI*2; problem.openAngle=(40+Math.random()*100)*(Math.PI/180); problem.len=Math.max(w,h)*0.7;
  } else if (type === 3) { 
    const ang=(Math.random()*30-15)*(Math.PI/180), cx=w/2, cy=h/2+50, len=Math.min(w,h)*0.85;
    const x1=cx-(len/2)*Math.cos(ang), y1=cy-(len/2)*Math.sin(ang), x2=cx+(len/2)*Math.cos(ang), y2=cy+(len/2)*Math.sin(ang);
    const t=0.35+Math.random()*0.3;
    problem.P={x:x1+(x2-x1)*t, y:y1+(y2-y1)*t}; problem.lineStart={x:x1,y:y1}; problem.lineEnd={x:x2,y:y2}; problem.lineAngle=ang;
  } else if (type === 4) { 
    const ang=(Math.random()*20-10)*(Math.PI/180), cx=w/2, cy=h*0.7, len=Math.min(w,h)*0.85;
    const x1=cx-(len/2)*Math.cos(ang), y1=cy-(len/2)*Math.sin(ang), x2=cx+(len/2)*Math.cos(ang), y2=cy+(len/2)*Math.sin(ang);
    const t=0.4+Math.random()*0.2, bx=x1+(x2-x1)*t, by=y1+(y2-y1)*t;
    const pDist=120+Math.random()*60, pAng=ang-Math.PI/2;
    problem.P={x:bx+pDist*Math.cos(pAng), y:by+pDist*Math.sin(pAng)}; problem.lineP={x:bx,y:by};
    problem.lineStart={x:x1,y:y1}; problem.lineEnd={x:x2,y:y2}; problem.lineAngle=ang;
  }
  currentProblem = problem; drawProblem(currentProblem); saveState();
  problemControls.style.display = &#39;block&#39;; answerButton.style.display = &#39;block&#39;; retryButton.style.display = &#39;block&#39;; 
}

function drawProblem(p) {
  const savedColor = currentColor; currentColor = &#39;black&#39;; ctx.fillStyle = &quot;black&quot;; ctx.font = &quot;20px Arial&quot;;
  if (p.type === 1) {
    ctx.fillText(&quot;ç·šåˆ† AB ã®å‚ç›´äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, 30, 50);
    drawLine(p.A.x, p.A.y, p.B.x, p.B.y, &#39;segment&#39;); 
    ctx.fillStyle = &quot;black&quot;; ctx.fillText(&quot;A&quot;, p.A.x-15, p.A.y+25); ctx.fillText(&quot;B&quot;, p.B.x-15, p.B.y+25);
  } else if (p.type === 2) {
    ctx.fillText(&quot;âˆ O ã®äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, 30, 50);
    const O=p.O, len=p.len, Xx=O.x+len*Math.cos(p.baseAngle), Xy=O.y+len*Math.sin(p.baseAngle);
    const Yx=O.x+len*Math.cos(p.baseAngle+p.openAngle), Yy=O.y+len*Math.sin(p.baseAngle+p.openAngle);
    ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle=&quot;black&quot;; ctx.moveTo(Xx, Xy); ctx.lineTo(O.x, O.y); ctx.lineTo(Yx, Yy); ctx.stroke();
    const ld=25, ca=p.baseAngle+p.openAngle/2+Math.PI; ctx.fillStyle=&quot;black&quot;; ctx.fillText(&quot;O&quot;, O.x+ld*Math.cos(ca)-6, O.y+ld*Math.sin(ca)+6);
  } else if (p.type === 3 || p.type === 4) {
    ctx.fillText(&quot;ç‚¹ P ã‚’é€šã‚‹å‚ç·šã‚’ä½œå›³ã—ãªã•ã„&quot;, 30, 50);
    drawLine(p.lineStart.x, p.lineStart.y, p.lineEnd.x, p.lineEnd.y, &#39;segment&#39;);
    drawPoint(p.P.x, p.P.y);
    ctx.fillStyle = &quot;black&quot;; ctx.fillText(&quot;X&quot;, p.lineStart.x+5, p.lineStart.y-10); ctx.fillText(&quot;Y&quot;, p.lineEnd.x-15, p.lineEnd.y-10); 
    ctx.fillText(&quot;P&quot;, p.P.x-5, p.type===3?p.P.y+25:p.P.y-15);
  }
  currentColor = savedColor;
}

function showAnswer() {
  if (!currentProblem) return;
  saveState(); 
  const savedColor = currentColor;
  const stepColors = [&#39;black&#39;, &#39;#007bff&#39;, &#39;#dc3545&#39;];
  let stepCount = 0;
  function drawDoubleSmartArc(center, r, angle1, angle2) {
    const color = stepColors[stepCount % 3]; const num = stepCount + 1;
    drawPoint(center.x, center.y, color, 6); 
    ctx.fillStyle = color; ctx.font = &quot;bold 24px Arial&quot;; ctx.fillText(num, center.x - 15, center.y - 15); 
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(center.x, center.y, r, angle1 - 0.4, angle1 + 0.4); ctx.stroke();
    ctx.beginPath(); ctx.arc(center.x, center.y, r, angle2 - 0.4, angle2 + 0.4); ctx.stroke();
    stepCount++;
  }
  function drawSmartArc(center, r, targetAngle) {
    const color = stepColors[stepCount % 3]; const num = stepCount + 1;
    drawPoint(center.x, center.y, color, 6); 
    ctx.fillStyle = color; ctx.font = &quot;bold 24px Arial&quot;; ctx.fillText(num, center.x - 15, center.y - 15); 
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(center.x, center.y, r, targetAngle - 0.4, targetAngle + 0.4); ctx.stroke();
    stepCount++;
  }
  const tasks = [];
  const originalDouble = drawDoubleSmartArc, originalSingle = drawSmartArc;
  drawDoubleSmartArc = (c, r, a1, a2) =&gt; tasks.push(() =&gt; originalDouble(c, r, a1, a2));
  drawSmartArc = (c, r, a) =&gt; tasks.push(() =&gt; originalSingle(c, r, a));

  if (currentProblem.type === 1 || currentProblem.type === &#39;levelup_bisector&#39;) {
      const A = (currentProblem.type === &#39;levelup_bisector&#39;) ? currentProblem.targetP1 : currentProblem.A;
      const B = (currentProblem.type === &#39;levelup_bisector&#39;) ? currentProblem.targetP2 : currentProblem.B;
      const dist = Math.hypot(B.x - A.x, B.y - A.y), r = dist * 0.7, angleAB = Math.atan2(B.y - A.y, B.x - A.x), delta = Math.acos((dist/2)/r);
      drawDoubleSmartArc(A, r, angleAB + delta, angleAB - delta); drawDoubleSmartArc(B, r, angleAB + Math.PI - delta, angleAB + Math.PI + delta);
      tasks.push(() =&gt; {
        const midX=(A.x+B.x)/2, midY=(A.y+B.y)/2, perpAngle=angleAB+Math.PI/2, len=1000;
        ctx.strokeStyle=&quot;#dc3545&quot;; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(midX-len*Math.cos(perpAngle), midY-len*Math.sin(perpAngle)); ctx.lineTo(midX+len*Math.cos(perpAngle), midY+len*Math.sin(perpAngle)); ctx.stroke();
      });
  } else if (currentProblem.type === 2 || currentProblem.type === &#39;levelup_angle_bisector&#39;) {
      let O, P1, P2;
      if(currentProblem.type===2) { O=currentProblem.O; P1={x:O.x+80*Math.cos(currentProblem.baseAngle), y:O.y+80*Math.sin(currentProblem.baseAngle)}; P2={x:O.x+80*Math.cos(currentProblem.baseAngle+currentProblem.openAngle), y:O.y+80*Math.sin(currentProblem.baseAngle+currentProblem.openAngle)}; }
      else { O=currentProblem.targetO; P1=currentProblem.targetArm1; P2=currentProblem.targetArm2; }
      const r1=80, a1=Math.atan2(P1.y-O.y, P1.x-O.x), a2=Math.atan2(P2.y-O.y, P2.x-O.x);
      drawDoubleSmartArc(O, r1, a1, a2);
      const c1={x:O.x+r1*Math.cos(a1), y:O.y+r1*Math.sin(a1)}, c2={x:O.x+r1*Math.cos(a2), y:O.y+r1*Math.sin(a2)};
      const bisectorAngle = Math.atan2(Math.sin(a1)+Math.sin(a2), Math.cos(a1)+Math.cos(a2));
      const r2=80, h_tri=Math.sqrt(r2*r2-(Math.hypot(c2.x-c1.x,c2.y-c1.y)/2)**2), tx=(c1.x+c2.x)/2+h_tri*Math.cos(bisectorAngle), ty=(c1.y+c2.y)/2+h_tri*Math.sin(bisectorAngle);
      drawSmartArc(c1, r2, Math.atan2(ty-c1.y, tx-c1.x)); drawSmartArc(c2, r2, Math.atan2(ty-c2.y, tx-c2.x));
      tasks.push(() =&gt; { ctx.strokeStyle=&quot;#dc3545&quot;; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(O.x,O.y); ctx.lineTo(O.x+1000*Math.cos(bisectorAngle),O.y+1000*Math.sin(bisectorAngle)); ctx.stroke(); });
      
  } else if (currentProblem.type === &#39;levelup_perp_online&#39; || currentProblem.type === 3) {
      const P = currentProblem.P, ang = currentProblem.lineAngle, r1=60;
      const i1={x:P.x+r1*Math.cos(ang), y:P.y+r1*Math.sin(ang)}, i2={x:P.x-r1*Math.cos(ang), y:P.y-r1*Math.sin(ang)};
      drawDoubleSmartArc(P, r1, ang, ang+Math.PI);
      const r2=80, pAng=ang+Math.PI/2, h=Math.sqrt(r2*r2-r1*r1), c={x:P.x+h*Math.cos(pAng), y:P.y+h*Math.sin(pAng)};
      drawSmartArc(i1, r2, Math.atan2(c.y-i1.y, c.x-i1.x)); drawSmartArc(i2, r2, Math.atan2(c.y-i2.y, c.x-i2.x));
      tasks.push(()=&gt;{ ctx.strokeStyle=&quot;#dc3545&quot;; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(P.x-1000*Math.cos(pAng), P.y-1000*Math.sin(pAng)); ctx.lineTo(P.x+1000*Math.cos(pAng), P.y+1000*Math.sin(pAng)); ctx.stroke(); });
      
  } else if (currentProblem.type === &#39;levelup_perp_offline&#39; || currentProblem.type === 4) {
      const P = currentProblem.P;
      const baseP = currentProblem.lineP; 
      const ang = currentProblem.lineAngle;
      const dist = Math.hypot(P.x-baseP.x, P.y-baseP.y);
      const R1 = dist * 1.3;
      const vx=baseP.x-P.x, vy=baseP.y-P.y, ux=Math.cos(ang), uy=Math.sin(ang);
      const B=2*(vx*ux+vy*uy), C=(vx*vx+vy*vy)-R1*R1, det=B*B-4*C, t1=(-B+Math.sqrt(det))/2, t2=(-B-Math.sqrt(det))/2;
      const I1={x:baseP.x+t1*ux, y:baseP.y+t1*uy}, I2={x:baseP.x+t2*ux, y:baseP.y+t2*uy};
      drawDoubleSmartArc(P, R1, Math.atan2(I1.y-P.y,I1.x-P.x), Math.atan2(I2.y-P.y,I2.x-P.x));
      const R2=R1*1.1;
      const mx=(I1.x+I2.x)/2, my=(I1.y+I2.y)/2;
      const distM=Math.sqrt(R2*R2-(Math.hypot(I1.x-I2.x,I1.y-I2.y)/2)**2);
      let nAng=ang+Math.PI/2; 
      if(Math.hypot(mx+Math.cos(nAng)-P.x, my+Math.sin(nAng)-P.y) &lt; Math.hypot(mx-Math.cos(nAng)-P.x, my-Math.sin(nAng)-P.y)) {
          nAng-=Math.PI;
      }
      const TX={x:mx+distM*Math.cos(nAng), y:my+distM*Math.sin(nAng)};
      drawSmartArc(I1, R2, Math.atan2(TX.y-I1.y,TX.x-I1.x)); 
      drawSmartArc(I2, R2, Math.atan2(TX.y-I2.y,TX.x-I2.x));
      tasks.push(()=&gt;{ 
          ctx.strokeStyle=&quot;#dc3545&quot;; ctx.lineWidth=3; ctx.beginPath(); 
          const dx=TX.x-P.x, dy=TX.y-P.y, l=Math.hypot(dx,dy);
          ctx.moveTo(P.x-(dx/l)*2000, P.y-(dy/l)*2000); 
          ctx.lineTo(P.x+(dx/l)*2000, P.y+(dy/l)*2000); 
          ctx.stroke();
      });
  }
  overlay.style.display = &#39;block&#39;;
  let i = 0;
  function run() {
    if (i &lt; tasks.length) { tasks[i](); i++; setTimeout(run, 800); } 
    else { overlay.style.display = &#39;none&#39;; saveState(); currentColor = savedColor; }
  }
  run();
}

imageInput.addEventListener(&#39;change&#39;, function(e) {
  const file = e.target.files[0];
  if (file) { handleImageFile(file); imageInput.value = &#39;&#39;; }
});
function setupImagePaste() {
  window.addEventListener(&#39;paste&#39;, function(e) {
    const items = (e.clipboardData || e.originalEvent.clipboardData).items;
    for (let i = 0; i &lt; items.length; i++) {
      if (items[i].type.indexOf(&#39;image&#39;) !== -1) { handleImageFile(items[i].getAsFile()); e.preventDefault(); break; }
    }
  });
}
function handleImageFile(file) {
  const reader = new FileReader();
  reader.onload = function(event) {
    const img = new Image();
    img.onload = function() {
      let dw = img.width, dh = img.height;
      const mw = canvas.width * 0.8, mh = canvas.height * 0.8;
      if (dw &gt; mw || dh &gt; mh) { const r = Math.min(mw / dw, mh / dh); dw *= r; dh *= r; }
      ctx.drawImage(img, (canvas.width - dw)/2, (canvas.height - dh)/2, dw, dh);
      saveState();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
}

function saveState() { redoStack = []; history.push(canvas.toDataURL()); if (history.length &gt; 30) history.shift(); }
function restoreState(dataURL) {
    const img = new Image();
    img.onload = function() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); };
    img.src = dataURL;
}
 
function undoAction() {
  if (currentTool === &#39;moving_point&#39;) {
    if (isMovingPointSet) { toggleMovingSet(); return; }
    if (movingPoints.length &gt; 0) { movingPoints.pop(); drawMovingPoints(); return; }
  }
  if (history.length &gt; 1) { 
    redoStack.push(history.pop()); restoreState(history[history.length - 1]); 
    if (currentTool === &#39;moving_point&#39;) { movingPoints = []; }
    lineStartPoint = null; 
  }
}
 
function redoAction() { if (redoStack.length &gt; 0) { const next = redoStack.pop(); history.push(next); restoreState(next); lineStartPoint = null; } }
function resetCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height); history = []; redoStack = []; saveState(); lineStartPoint = null;
  currentProblem = null; problemControls.style.display = &#39;none&#39;;
  movingPoints = []; 
  overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  resetView(); 
}

// --- ã‚³ãƒ³ãƒ‘ã‚¹UI ---
function updateCompassUI() {
  compassPivot.style.left = compass.pivotX + &#39;px&#39;;
  compassPivot.style.top = compass.pivotY + &#39;px&#39;;
  compassArm.style.left = compass.pivotX + &#39;px&#39;;
  compassArm.style.top = compass.pivotY + &#39;px&#39;;
  compassArm.style.width = compass.radius + &#39;px&#39;;
  compassArm.style.transform = `rotate(${compass.angle * 180 / Math.PI}deg)`;
  const pencilOffset = 40; 
  const pencilX = compass.pivotX + (compass.radius + pencilOffset) * Math.cos(compass.angle);
  const pencilY = compass.pivotY + (compass.radius + pencilOffset) * Math.sin(compass.angle);
  pencilDrawHandle.style.left = pencilX + &#39;px&#39;;
  pencilDrawHandle.style.top = pencilY + &#39;px&#39;;
  pencilDrawHandle.style.transform = `translate(-50%, -50%)`;
}

function startCompassDrag(e) {
  if (currentTool !== &#39;compass&#39;) return;
  e.preventDefault(); e.stopPropagation();
  const targetId = e.currentTarget.id;
  if (targetId === &#39;compassPivot&#39;) compass.dragTarget = &#39;pivot&#39;;
  else if (targetId === &#39;pencilTip&#39;) compass.dragTarget = &#39;radius&#39;;
  else if (targetId === &#39;pencilDrawHandle&#39;) {
    compass.dragTarget = &#39;draw&#39;; compass.centerDrawn = false;
    ctx.beginPath(); ctx.strokeStyle = currentColor; ctx.lineWidth = (currentColor === &#39;white&#39;) ? 20 : 2; 
    ctx.moveTo(compass.pivotX + compass.radius * Math.cos(compass.angle), compass.pivotY + compass.radius * Math.sin(compass.angle));
  }
  compass.isDragging = true;
  document.addEventListener(&#39;mousemove&#39;, dragCompass);
  document.addEventListener(&#39;touchmove&#39;, dragCompass, {passive: false});
  document.addEventListener(&#39;mouseup&#39;, endCompassDrag);
  document.addEventListener(&#39;touchend&#39;, endCompassDrag);
}

function dragCompass(e) {
  if (!compass.isDragging) return;
  e.preventDefault();
  const pos = getEventPos(e);

  if (compass.dragTarget === &#39;pivot&#39;) {
    compass.pivotX = pos.x; compass.pivotY = pos.y;
  } else if (compass.dragTarget === &#39;radius&#39;) {
    const dx = pos.x - compass.pivotX, dy = pos.y - compass.pivotY;
    if (compass.locked) { compass.angle = Math.atan2(dy, dx); }
    else {
      const newRadius = Math.sqrt(dx*dx + dy*dy);
      if (newRadius &gt; 20) { compass.radius = newRadius; compass.angle = Math.atan2(dy, dx); }
    }
  } else if (compass.dragTarget === &#39;draw&#39;) {
    if (!compass.centerDrawn) { drawPoint(compass.pivotX, compass.pivotY, &#39;red&#39;); compass.centerDrawn = true; ctx.beginPath(); ctx.strokeStyle = currentColor; ctx.lineWidth = (currentColor === &#39;white&#39;) ? 20 : 2; }
    const dx = pos.x - compass.pivotX, dy = pos.y - compass.pivotY;
    const newAngle = Math.atan2(dy, dx);
    let diff = newAngle - compass.angle;
    while (diff &lt;= -Math.PI) diff += 2 * Math.PI; while (diff &gt; Math.PI) diff -= 2 * Math.PI;
    ctx.beginPath(); ctx.strokeStyle = currentColor; ctx.lineWidth = (currentColor === &#39;white&#39;) ? 20 : 2;
    ctx.arc(compass.pivotX, compass.pivotY, compass.radius, compass.angle, newAngle, diff &lt; 0);
    ctx.stroke();
    compass.angle = newAngle;
  }
  updateCompassUI();
}

function endCompassDrag(e) {
  if (compass.isDragging) {
    if (compass.dragTarget === &#39;draw&#39;) { saveState(); compass.locked = true; updateLockUI(); }
    compass.isDragging = false; compass.dragTarget = null;
    document.removeEventListener(&#39;mousemove&#39;, dragCompass);
    document.removeEventListener(&#39;touchmove&#39;, dragCompass);
    document.removeEventListener(&#39;mouseup&#39;, endCompassDrag);
    document.removeEventListener(&#39;touchend&#39;, endCompassDrag);
  }
}
 
// === â˜…åˆ†åº¦å™¨ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç† ===
function startProtractorDrag(e) {
   if (currentTool !== &#39;protractor&#39;) return;
   e.preventDefault(); e.stopPropagation();
   
   const targetId = e.target.id;
   if (targetId === &#39;protractorRotateHandle&#39;) {
      protractor.dragTarget = &#39;rotate&#39;;
   } else {
      protractor.dragTarget = &#39;move&#39;;
   }
   protractor.isDragging = true;
   
   document.addEventListener(&#39;mousemove&#39;, dragProtractor);
   document.addEventListener(&#39;touchmove&#39;, dragProtractor, {passive: false});
   document.addEventListener(&#39;mouseup&#39;, endProtractorDrag);
   document.addEventListener(&#39;touchend&#39;, endProtractorDrag);
}
 
function dragProtractor(e) {
   if (!protractor.isDragging) return;
   e.preventDefault();
   const pos = getEventPos(e);
   
   if (protractor.dragTarget === &#39;move&#39;) {
      // ä¸‹ç«¯ä¸­å¤®ãŒ (x, y) ãªã®ã§ã€ãƒã‚¦ã‚¹ä½ç½®ã«åˆã‚ã›ã‚‹
      protractor.x = pos.x;
      protractor.y = pos.y;
   } else if (protractor.dragTarget === &#39;rotate&#39;) {
      // ä¸­å¿ƒ(x,y)ã‹ã‚‰ãƒã‚¦ã‚¹ä½ç½®ã¸ã®è§’åº¦
      const dx = pos.x - protractor.x;
      const dy = pos.y - protractor.y;
      protractor.angle = Math.atan2(dy, dx);
   }
   updateProtractorUI();
}
 
function endProtractorDrag() {
   if (protractor.isDragging) {
      protractor.isDragging = false;
      protractor.dragTarget = null;
      document.removeEventListener(&#39;mousemove&#39;, dragProtractor);
      document.removeEventListener(&#39;touchmove&#39;, dragProtractor);
      document.removeEventListener(&#39;mouseup&#39;, endProtractorDrag);
      document.removeEventListener(&#39;touchend&#39;, endProtractorDrag);
   }
}

function addToolListeners() {
  compassPivot.addEventListener(&#39;mousedown&#39;, startCompassDrag);
  compassPivot.addEventListener(&#39;touchstart&#39;, startCompassDrag, {passive: false});
  pencilTip.addEventListener(&#39;mousedown&#39;, startCompassDrag);
  pencilTip.addEventListener(&#39;touchstart&#39;, startCompassDrag, {passive: false});
  pencilDrawHandle.addEventListener(&#39;mousedown&#39;, startCompassDrag);
  pencilDrawHandle.addEventListener(&#39;touchstart&#39;, startCompassDrag, {passive: false});
   
  // â˜…åˆ†åº¦å™¨ãƒªã‚¹ãƒŠãƒ¼
  protractorBody.addEventListener(&#39;mousedown&#39;, startProtractorDrag);
  protractorBody.addEventListener(&#39;touchstart&#39;, startProtractorDrag, {passive: false});
   
  drawingArea.addEventListener(&#39;mousedown&#39;, handleStart);
  drawingArea.addEventListener(&#39;touchstart&#39;, handleStart, {passive: false});
  window.addEventListener(&#39;mousemove&#39;, handleMove); 
  window.addEventListener(&#39;touchmove&#39;, handleMove, {passive: false});
  window.addEventListener(&#39;mouseup&#39;, handleEnd);
  window.addEventListener(&#39;touchend&#39;, handleEnd);
}

function handleStart(e) {
  if (e.target.classList.contains(&#39;view-slider&#39;)) return;
  if (currentTool === &#39;protractor&#39;) return; 
   
  if (e.touches &amp;&amp; e.touches.length === 2) {
    isPanning = true;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    initialPinchDist = Math.hypot(dx, dy);
    initialScale = view.scale;
    
    const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    startPan = { x: cx - view.x, y: cy - view.y };
    return;
  }
   
  if (currentTool === &#39;compass&#39;) return;
  if (!drawingArea.contains(e.target)) return;

  e.preventDefault(); 
  const pos = getEventPos(e);
   
  if (currentTool === &#39;moving_point&#39;) {
    if (!isMovingPointSet) {
       movingPoints.push({x: pos.x, y: pos.y});
       drawMovingPoints();
    } else {
       for(let i=0; i&lt;movingPoints.length; i++) {
          const dx = pos.x - movingPoints[i].x;
          const dy = pos.y - movingPoints[i].y;
          if (dx*dx + dy*dy &lt; 400) { 
             dragMovingPointIndex = i;
             break;
          }
       }
    }
  }
  else if (currentTool === &#39;point&#39;) { 
    drawPoint(pos.x, pos.y); saveState(); 
  }
  else if (currentTool === &#39;freehand&#39; || currentTool === &#39;eraser&#39;) { 
    isDrawing = true; 
    ctx.beginPath(); 
    ctx.moveTo(pos.x, pos.y); 
    ctx.strokeStyle = (currentTool === &#39;eraser&#39;) ? &#39;white&#39; : currentColor; 
    ctx.lineWidth = (currentTool === &#39;eraser&#39;) ? 20 : 2; 
    ctx.lineCap = &#39;round&#39;; 
  }
  else if (currentTool === &#39;line&#39; || currentTool === &#39;ruler&#39;) {
    if (!lineStartPoint) { lineStartPoint = pos; drawPoint(pos.x, pos.y, &#39;red&#39;); }
    else { 
      const type = (currentTool === &#39;ruler&#39;) ? &#39;line&#39; : &#39;segment&#39;;
      drawLine(lineStartPoint.x, lineStartPoint.y, pos.x, pos.y, type);
      lineStartPoint = null; saveState();
    }
  }
}
 
function drawMovingPoints() {
   overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
   _drawMovingOverlay();
}
 
function _drawMovingOverlay() {
   if (movingPoints.length === 0) return;
   
   overlayCtx.lineWidth = 2;
   overlayCtx.strokeStyle = &quot;black&quot;;
   
   if (movingPoints.length &gt; 1) {
     overlayCtx.beginPath();
     overlayCtx.moveTo(movingPoints[0].x, movingPoints[0].y);
     for(let i=1; i&lt;movingPoints.length; i++) {
        overlayCtx.lineTo(movingPoints[i].x, movingPoints[i].y);
     }
     if (movingPoints.length &gt;= 3) {
        overlayCtx.closePath();
        if (isMovingFillMode) {
           overlayCtx.fillStyle = &quot;rgba(220, 53, 69, 0.2)&quot;; 
           overlayCtx.fill();
        }
     }
     overlayCtx.stroke();
   }
   
   for(let i=0; i&lt;movingPoints.length; i++) {
      drawSingleMovingPoint(movingPoints[i].x, movingPoints[i].y);
   }
}
 
function drawSingleMovingPoint(x, y) {
  overlayCtx.fillStyle = &quot;#dc3545&quot;; 
  overlayCtx.beginPath(); overlayCtx.arc(x, y, 3, 0, Math.PI * 2); overlayCtx.fill();
  overlayCtx.strokeStyle = &quot;black&quot;; overlayCtx.lineWidth = 1;
  overlayCtx.beginPath(); overlayCtx.arc(x, y, 6, 0, Math.PI * 2); overlayCtx.stroke();
}

function handleMove(e) {
  if (e.touches &amp;&amp; e.touches.length === 2 &amp;&amp; isPanning) {
     e.preventDefault();
     const dx = e.touches[0].clientX - e.touches[1].clientX;
     const dy = e.touches[0].clientY - e.touches[1].clientY;
     const currentDist = Math.hypot(dx, dy);
     if (initialPinchDist &gt; 0) {
       const newScale = initialScale * (currentDist / initialPinchDist);
       if (newScale &gt;= 0.5 &amp;&amp; newScale &lt;= 5.0) { view.scale = newScale; }
     }
     const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
     const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
     view.x = cx - startPan.x; view.y = cy - startPan.y;
     updateTransform();
     return;
  }

  if (currentTool === &#39;compass&#39;) return;
  if (currentTool === &#39;protractor&#39;) return; 
   
  if (currentTool === &#39;moving_point&#39; &amp;&amp; dragMovingPointIndex !== -1) {
     e.preventDefault();
     const pos = getEventPos(e);
     movingPoints[dragMovingPointIndex] = {x: pos.x, y: pos.y};
     drawMovingPoints();
     return;
  }

  if (!isDrawing &amp;&amp; !lineStartPoint) return;
  if (e.touches &amp;&amp; e.touches.length &gt; 1) return;

  e.preventDefault(); 
  const pos = getEventPos(e);
  if ((currentTool === &#39;freehand&#39; || currentTool === &#39;eraser&#39;) &amp;&amp; isDrawing) { ctx.lineTo(pos.x, pos.y); ctx.stroke(); }
}

function handleEnd(e) {
  isPanning = false;
  dragMovingPointIndex = -1; 
  if ((currentTool === &#39;freehand&#39; || currentTool === &#39;eraser&#39;) &amp;&amp; isDrawing) { isDrawing = false; saveState(); }
}

function drawPoint(x, y, color = currentColor, radius = 3) { 
  ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
}

function drawLine(x1, y1, x2, y2, type) {
  ctx.strokeStyle = currentColor; 
  ctx.lineWidth = 2; ctx.beginPath();
  if (type === &#39;segment&#39;) { ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); }
  else { const ep = getExtendedLine(x1, y1, x2, y2); ctx.moveTo(ep.x1, ep.y1); ctx.lineTo(ep.x2, ep.y2); }
  ctx.stroke(); drawPoint(x1, y1); drawPoint(x2, y2);
}

function getExtendedLine(x1, y1, x2, y2) {
  const w = canvas.width; const h = canvas.height;
  if (x1 === x2) return { x1: x1, y1: 0, x2: x1, y2: h };
  if (y1 === y2) return { x1: 0, y1: y1, x2: w, y2: y1 };
  const m = (y2 - y1) / (x2 - x1); const b = y1 - m * x1;
  const pts = [];
  let y0 = b; if (y0 &gt;= 0 &amp;&amp; y0 &lt;= h) pts.push({x:0, y:y0});
  let yw = m * w + b; if (yw &gt;= 0 &amp;&amp; yw &lt;= h) pts.push({x:w, y:yw});
  let x0 = -b / m; if (x0 &gt;= 0 &amp;&amp; x0 &lt;= w) pts.push({x:x0, y:0});
  let xh = (h - b) / m; if (xh &gt;= 0 &amp;&amp; xh &lt;= w) pts.push({x:xh, y:h});
  if (pts.length &gt;= 2) return { x1: pts[0].x, y1: pts[0].y, x2: pts[pts.length-1].x, y2: pts[pts.length-1].y };
  return { x1: x1, y1: y1, x2: x2, y2: y2 }; 
}

/* --- JS END --- */
</script>

</body> </html>
