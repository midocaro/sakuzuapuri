<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ä½œå›³ã‚¢ãƒ—ãƒªVer6.3</title>
  <style>
    /* --- CSS START --- */
    
    /* === å…¨ä½“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ === */
    body {
      margin: 0; padding: 0; font-family: Arial, sans-serif;
      display: flex; height: 100vh; height: 100dvh; 
      overflow: hidden; 
      touch-action: none; 
    }

    /* === å·¦å´ï¼šæ“ä½œãƒ‘ãƒãƒ«ï¼ˆå…¨ä½“æ ï¼‰ === */
    #controls {
      width: 260px; background-color: #f8f9fa; 
      padding: 0;
      box-shadow: 2px 0 8px rgba(0,0,0,0.1); 
      overflow: hidden; 
      flex-shrink: 0; display: flex; flex-direction: column; 
      z-index: 10001; 
    }

    /* === å›ºå®šã‚¨ãƒªã‚¢ï¼ˆä¸Šéƒ¨ï¼‰ === */
    #fixed-section {
      flex-shrink: 0; 
      padding: 15px 15px 10px 15px; 
      background-color: #f8f9fa;
      border-bottom: 2px solid #ddd; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      z-index: 10002;
      display: flex; flex-direction: column; gap: 10px;
    }

    /* === ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ï¼ˆä¸­å¤®ï¼‰ === */
    #scrollable-section {
      flex-grow: 1; 
      overflow-y: auto; 
      padding: 15px;
      display: flex; flex-direction: column; gap: 15px;
      touch-action: pan-y; 
    }

    /* === ãƒãƒŠãƒ¼ã‚¨ãƒªã‚¢ï¼ˆé»’èƒŒæ™¯ãƒ»ä¸‹éƒ¨å›ºå®šï¼‰ === */
    #footer-banner {
      flex-shrink: 0;
      padding: 15px 10px; 
      text-align: center; 
      background-color: #343a40; /* ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼èƒŒæ™¯ */
      color: #ffffff;
      z-index: 10002;
      font-size: 12px;
    }
    #footer-banner a {
      color: #ffffff;
      text-decoration: none;
      font-weight: bold;
      display: block;
      line-height: 1.4;
    }
    #footer-banner a:hover {
      opacity: 0.8;
      text-decoration: underline;
    }

    h3 {
      margin: 0 0 5px 0; font-size: 14px; color: #555; 
      font-weight: bold;
    }
     
    .section-title {
      font-size: 16px; color: #333; margin: 0 0 10px 0;
      border-bottom: 2px solid #ddd; padding-bottom: 5px;
    }

    /* ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ */
    .radio-group { display: flex; flex-direction: column; gap: 10px; }
    .radio-label {
      display: flex; align-items: center; cursor: pointer; padding: 8px;
      background: white; border-radius: 6px; border: 1px solid #ddd;
      transition: background 0.2s;
    }
    .radio-label:hover { background: #e9ecef; }
    .radio-label input { margin-right: 10px; transform: scale(1.2); }

    /* ãƒœã‚¿ãƒ³ */
    .btn-group { display: flex; gap: 10px; }
    .btn-group-vertical { display: flex; flex-direction: column; gap: 8px; }

    .action-button {
      flex: 1; padding: 12px; border: none; background-color: #007bff;
      color: white; font-weight: bold; border-radius: 6px; cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background-color 0.2s;
      font-size: 14px; 
    }
    .action-button:active { transform: translateY(2px); box-shadow: none; }
    #reset-button { background-color: #dc3545; }
     
    /* å†ç”Ÿé–¢é€£ãƒœã‚¿ãƒ³ */
    #start-replay-button { background-color: #6f42c1; width: 100%; }
    #pause-button { background-color: #ffc107; color: black; }
    #stop-button { background-color: #dc3545; }
     
    /* è¦–ç‚¹æ“ä½œãƒœã‚¿ãƒ³ */
    #reset-view-button { background-color: #6c757d; margin-bottom: 5px; }

    /* å‹•ç‚¹ã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ */
    #set-moving-button {
       background-color: #28a745; display: none; margin-top: 5px;
    }
    #set-moving-button.is-active {
       background-color: #dc3545; 
    }
     
    /* å‹•ç‚¹ç”¨è‰²å¡—ã‚Šã‚¹ã‚¤ãƒƒãƒ */
    #moving-fill-container {
      display: none; align-items: center; justify-content: space-between;
      background: #fff; padding: 8px; border-radius: 6px; 
      border: 1px solid #ddd; margin-top: 5px;
    }
     
    /* ã‚°ãƒ©ãƒ•å…¥åŠ›ã‚¨ãƒªã‚¢ */
    #graph-controls {
      display: none; 
      background: #e9ecef; padding: 8px; border-radius: 6px;
      flex-direction: column; gap: 6px;
    }
    .graph-label {
      font-size: 12px; font-weight: bold; color: #555; margin-bottom: 2px;
    }
    .graph-input-row {
      display: flex; align-items: center; 
      justify-content: space-between;
      gap: 1px;
      font-size: 10px; font-weight: bold; 
      white-space: nowrap;
    }
    .graph-input-row input {
      width: 24px; padding: 3px 1px; text-align: center; border: 1px solid #ccc; border-radius: 3px;
      font-size: 11px;
    }
    .graph-add-btn {
      padding: 4px 0; font-size: 12px; width: 100%; margin-top: 5px;
    }

    .practice-button { background-color: #17a2b8; text-align: left; padding-left: 15px; }
    .levelup-button { background-color: #fd7e14; text-align: left; padding-left: 15px; }
    #random-button { background-color: #ff9800; text-align: center; font-size: 16px; }
    #answer-button { background-color: #e83e8c; text-align: center; margin-top: 5px; }
    #retry-button { background-color: #20c997; }
    #add-image-button { background-color: #28a745; color: white; width: 100%; }

    /* ãƒ­ãƒƒã‚¯ãƒœã‚¿ãƒ³ */
    #lock-button { background-color: #6c757d; display: none; color: white; }
    #lock-button.is-locked { background-color: #dc3545; }

    /* ä½œå›³ãƒ¢ãƒ¼ãƒ‰ãƒ»æ–¹çœ¼ç´™ã‚¹ã‚¤ãƒƒãƒå…±é€š */
    .mode-switch-container {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px; background: #e2e6ea; border-radius: 6px; font-weight: bold; color: #333;
    }
    .switch { position: relative; display: inline-block; width: 50px; height: 26px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc; transition: .4s; border-radius: 34px;
    }
    .slider:before {
      position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px;
      background-color: white; transition: .4s; border-radius: 50%;
    }
    input:checked + .slider { background-color: #28a745; }
    input:checked + .slider:before { transform: translateX(24px); }

    .color-group { display: flex; gap: 5px; }
    .color-label {
      flex: 1; display: flex; justify-content: center; align-items: center;
      padding: 8px; cursor: pointer; background: white;
      border-radius: 6px; border: 1px solid #ddd; font-weight: bold;
    }
    .color-label:hover { background: #e9ecef; }
    .color-label input { margin-right: 5px; transform: scale(1.2); }

    .credit-line { margin-top: 20px; text-align: center; font-size: 12px; color: #888; font-weight: bold; }

    #overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255, 255, 255, 0); z-index: 10000; display: none; cursor: wait;
    }

    /* === å³å´ï¼šæç”»ã‚¨ãƒªã‚¢æ  === */
    #drawing-area {
      flex-grow: 1; 
      background-color: #e0e0e0; 
      position: relative; overflow: hidden; touch-action: none; 
      cursor: crosshair; 
    }

    /* === å®Ÿéš›ã«å¤‰å½¢ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ç§»å‹•ï¼‰ã™ã‚‹ä¸­èº« === */
    #canvas-content {
      position: absolute; top: 0; left: 0; 
      transform-origin: 0 0;
      background-color: #ffffff;
      box-shadow: 0 0 20px rgba(0,0,0,0.1); 
    }
     
    /* æ–¹çœ¼ç´™ï¼ˆã‚°ãƒªãƒƒãƒ‰ï¼‰ç”¨ã‚¯ãƒ©ã‚¹ï¼š25pxé–“éš” */
    .grid-background {
      background-image: 
        linear-gradient(#e0e0e0 1px, transparent 1px),
        linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
      background-size: 25px 25px;
    }

    #main-canvas { 
      display: block; 
      position: absolute; top: 0; left: 0; z-index: 10; 
    }
     
    /* åº§æ¨™è»¸ãƒ»ã‚°ãƒ©ãƒ•ç”¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ */
    #axis-canvas {
      display: none; 
      position: absolute; top: 0; left: 0; z-index: 5;
      pointer-events: none; 
    }

    /* â˜…å‹•ç‚¹ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰ */
    #overlay-canvas {
      display: block;
      position: absolute; top: 0; left: 0; z-index: 15; /* Mainã®ä¸Šã€Compassã®ä¸‹ */
      pointer-events: none; /* ã‚¯ãƒªãƒƒã‚¯ã‚’é€é */
    }

    /* === ã‚³ãƒ³ãƒ‘ã‚¹UI === */
    #compassContainer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; display: none; z-index: 100;
    }

    #compassPivot {
      position: absolute; width: 10px; height: 10px; 
      background: rgba(220, 53, 69, 0.7); border: 1px solid white; border-radius: 50%; z-index: 110; 
      cursor: crosshair; pointer-events: auto; transform: translate(-50%, -50%); 
      box-shadow: 0 0 2px rgba(0,0,0,0.5);
    }
    #compassPivot::before { content: ''; position: absolute; top: -20px; left: -20px; right: -20px; bottom: -20px; }

    #compassArm {
      position: absolute; height: 2px; background: rgba(100, 100, 100, 0.5);
      transform-origin: left center; z-index: 95; pointer-events: none; border-radius: 2px;
    }
     
    #pencilTip {
      position: absolute; width: 26px; height: 26px; background: #007bff; 
      border: 2px solid white; border-radius: 50%; right: 25px; top: -12px;       
      pointer-events: auto; cursor: ew-resize; z-index: 130;        
      box-shadow: 0 2px 5px rgba(0,0,0,0.4); transition: background-color 0.2s;
      display: flex; justify-content: center; align-items: center;
      color: white; font-weight: bold; font-size: 16px; line-height: 1;
    }
    #pencilTip::after { content: 'â†”'; padding-bottom: 2px; }
    #pencilTip::before { content: ''; position: absolute; top: -25px; bottom: -25px; left: -25px; right: 25px; }
    #pencilTip.locked { background: #dc3545; cursor: move; }
    #pencilTip.locked::after { content: ''; }

    #pencilDrawHandle {
      position: absolute; width: 40px; height: 40px; line-height: 40px;
      text-align: center; font-size: 24px; z-index: 120;
      pointer-events: auto; cursor: grabbing; background: white;
      border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      transition: transform 0.1s;
    }
    #pencilDrawHandle:active { background: #eef; }
     
    /* === â˜…åˆ†åº¦å™¨UI === */
    #protractorContainer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; display: none; z-index: 90; /* ã‚³ãƒ³ãƒ‘ã‚¹ã‚ˆã‚Šä¸‹ */
    }
     
    #protractorBody {
      position: absolute; width: 340px; height: 170px; /* åŠå¾„170px */
      z-index: 91; pointer-events: auto; cursor: move;
      /* ä¸­å¿ƒç‚¹ã‚’åŸºæº–ã«å›è»¢ãƒ»ç§»å‹• */
      transform-origin: 50% 100%; 
    }
     
    #protractorCanvas {
      width: 100%; height: 100%; display: block;
    }
     
    #protractorRotateHandle {
      position: absolute; right: -20px; bottom: -20px; width: 40px; height: 40px;
      background: white; border-radius: 50%; border: 1px solid #ccc;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 95;
      display: flex; justify-content: center; align-items: center;
      font-size: 20px; cursor: grabbing; pointer-events: auto;
    }
     
    /* === ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« === */
    .view-slider {
      position: absolute;
      z-index: 2000;
      opacity: 0.6;
      transition: opacity 0.2s;
      touch-action: pan-x pan-y; 
    }
    .view-slider:hover, .view-slider:active {
      opacity: 1.0;
    }
     
    /* æ¨ªã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆä¸‹ï¼‰ */
    #slider-x {
      bottom: 60px; left: 50px; right: 50px;
      height: 20px; width: auto;
    }
     
    /* ç¸¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆå³ï¼‰ */
    #slider-y {
      top: 50%; right: -100px;
      width: 250px; height: 20px;
      transform: rotate(90deg) translate(0, -50%);
      transform-origin: center;
    }
     
    @media (max-width: 600px) {
      #slider-x { left: 10px; right: 10px; bottom: 65px; }
      #slider-y { right: -110px; width: 250px; }
    }

    @media (min-width: 601px) and (max-width: 1024px) {
      #controls { width: 200px; padding: 0; }
      #fixed-section, #scrollable-section { padding: 10px; }
      h3 { font-size: 15px; }
    }
    @media (max-width: 600px) {
      #controls { width: 60px; padding: 0; }
      #fixed-section, #scrollable-section { padding: 5px; }
      h3, .radio-label span { display: none; }
      .radio-label { justify-content: center; }
      .radio-label input { margin: 0; transform: scale(1.5); }
      .btn-group { flex-direction: column; }
    }
    
    /* --- CSS END --- */
  </style>
</head>
<body>

  <div id="overlay"></div>

  <div id="controls">
    <div id="fixed-section">
      <div class="control-group">
        <h3>æ“ä½œ</h3>
        <div class="btn-group">
          <button class="action-button" onclick="undoAction()">æˆ»ã‚‹</button>
          <button class="action-button" onclick="redoAction()">é€²ã‚€</button>
          <button class="action-button" id="reset-button" onclick="resetCanvas()">æ¶ˆå»</button>
        </div>
      </div>

      <div class="control-group">
        <h3>ç·šã®è‰²</h3>
        <div class="color-group">
          <label class="color-label" style="color: black;"><input type="radio" name="color" value="black" onchange="setColor(this.value)" checked> é»’</label>
          <label class="color-label" style="color: #dc3545;"><input type="radio" name="color" value="#dc3545" onchange="setColor(this.value)"> èµ¤</label>
          <label class="color-label" style="color: #007bff;"><input type="radio" name="color" value="#007bff" onchange="setColor(this.value)"> é’</label>
        </div>
      </div>
    </div>

    <div id="scrollable-section">
       
      <div class="control-group">
        <div style="margin-bottom: 0;">
          <button class="action-button" id="start-replay-button" onclick="startPlayback()">â–¶ ä½œå›³ã‚’å†ç”Ÿ</button>
          <div id="playback-controls" style="display:none; gap:5px; display:flex;">
             <button class="action-button" id="pause-button" onclick="togglePause()">â¸ ä¸€æ™‚åœæ­¢</button>
             <button class="action-button" id="stop-button" onclick="stopPlayback()">â¹ çµ‚äº†</button>
          </div>
        </div>
      </div>

      <div class="control-group">
        <h3 class="section-title">ãƒ„ãƒ¼ãƒ«</h3>
        <div class="radio-group">
          <label class="radio-label" id="label-point"><input type="radio" name="tool" value="point" onchange="setTool(this.value)" checked><span>ç‚¹</span></label>
          <label class="radio-label" id="label-moving_point"><input type="radio" name="tool" value="moving_point" onchange="setTool(this.value)"><span>å‹•ç‚¹</span></label>
          <label class="radio-label" id="label-line"><input type="radio" name="tool" value="line" onchange="setTool(this.value)"><span>ç‚¹ã¨ç‚¹ã‚’çµã¶</span></label>
          <label class="radio-label" id="label-ruler"><input type="radio" name="tool" value="ruler" onchange="setTool(this.value)"><span>ç›´ç·šï¼ˆå®šè¦ï¼‰</span></label>
          <label class="radio-label" id="label-compass"><input type="radio" name="tool" value="compass" onchange="setTool(this.value)"><span>ã‚³ãƒ³ãƒ‘ã‚¹</span></label>
          <label class="radio-label" id="label-protractor"><input type="radio" name="tool" value="protractor" onchange="setTool(this.value)"><span>åˆ†åº¦å™¨</span></label>
           
          <label class="radio-label" id="label-freehand"><input type="radio" name="tool" value="freehand" onchange="setTool(this.value)"><span>ãƒ•ãƒªãƒ¼ãƒãƒ³ãƒ‰</span></label>
          <label class="radio-label" id="label-eraser"><input type="radio" name="tool" value="eraser" onchange="setTool(this.value)"><span>æ¶ˆã—ã‚´ãƒ </span></label>
        </div>
        
        <button class="action-button" id="set-moving-button" onclick="toggleMovingSet()">ã‚»ãƒƒãƒˆï¼ˆç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã¸ï¼‰</button>
        
        <div id="moving-fill-container">
          <span style="font-size: 13px; font-weight: bold; color: #555;">è‰²ã‚’å¡—ã‚‹</span>
          <label class="switch" style="transform: scale(0.9);">
            <input type="checkbox" id="moving-fill-toggle" onchange="toggleMovingFill()" checked>
            <span class="slider"></span>
          </label>
        </div>
      </div>
       
      <div class="control-group">
        <button class="action-button" id="reset-view-button" onclick="resetView()">ğŸ” è¦–ç‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
      </div>

      <div class="control-group" id="compass-controls" style="display:none;">
        <h3 class="section-title">ã‚³ãƒ³ãƒ‘ã‚¹è¨­å®š</h3>
        <button class="action-button" id="lock-button" onclick="toggleCompassLock()">å¹…ã‚’ãƒ­ãƒƒã‚¯</button>
      </div>

      <div class="control-group">
        <div class="mode-switch-container">
          <span>ä½œå›³ãƒ¢ãƒ¼ãƒ‰</span>
          <label class="switch"><input type="checkbox" id="mode-toggle" onchange="toggleDrawingMode()"><span class="slider"></span></label>
        </div>
      </div>
       
      <div class="control-group">
        <div class="mode-switch-container">
          <span>æ–¹çœ¼ç´™</span>
          <label class="switch"><input type="checkbox" id="grid-toggle" onchange="toggleGrid()"><span class="slider"></span></label>
        </div>
      </div>
       
      <div class="control-group">
        <div class="mode-switch-container">
          <span>åº§æ¨™è»¸</span>
          <label class="switch"><input type="checkbox" id="axis-toggle" onchange="toggleAxis()"><span class="slider"></span></label>
        </div>
        
        <div id="graph-controls">
          <div class="graph-label">y = axÂ³ + bxÂ² + cx + d</div>
          <div class="graph-input-row">
            <input type="text" id="poly-a" value="0" placeholder="a" oninput="updatePolyPreview()">xÂ³+
            <input type="text" id="poly-b" value="0" placeholder="b" oninput="updatePolyPreview()">xÂ²+
            <input type="text" id="poly-c" value="0" placeholder="c" oninput="updatePolyPreview()">x+
            <input type="text" id="poly-d" value="0" placeholder="d" oninput="updatePolyPreview()">
          </div>
          <button class="action-button graph-add-btn" onclick="addPolyGraph()">ã‚°ãƒ©ãƒ•ã‚’è¿½åŠ </button>
          <button class="action-button" onclick="clearGraphs()" style="background-color: #dc3545; font-size: 11px; padding: 6px; width:100%; margin-top:5px;">ã‚°ãƒ©ãƒ•ã‚’å…¨æ¶ˆå»</button>
        </div>
      </div>
       
      <div class="control-group">
        <h3 class="section-title">ç”»åƒæŒ¿å…¥</h3>
        <input type="file" id="image-input" accept="image/*" style="display: none;">
        <button class="action-button" id="add-image-button" onclick="document.getElementById('image-input').click()">ç”»åƒã‚’è¿½åŠ </button>
      </div>
       
      <div class="control-group">
        <h3 class="section-title" onclick="toggleSection('basic-practice-list', this)" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
          åŸºæœ¬ä½œå›³ã®ç·´ç¿’ <span>â–¼</span>
        </h3>
        <div id="basic-practice-list">
          <div class="btn-group-vertical">
            <button class="action-button practice-button" onclick="startPractice(1)">â‘ ç·šåˆ†ã®å‚ç›´äºŒç­‰åˆ†ç·š</button>
            <button class="action-button practice-button" onclick="startPractice(2)">â‘¡è§’ã®äºŒç­‰åˆ†ç·š</button>
            <button class="action-button practice-button" onclick="startPractice(3)">â‘¢ç›´ç·šä¸Šã®ç‚¹ã‚’é€šã‚‹å‚ç·š</button>
            <button class="action-button practice-button" onclick="startPractice(4)">â‘£ç›´ç·šä¸Šã«ãªã„ç‚¹ã‚’é€šã‚‹å‚ç·š</button>
            <button class="action-button" id="random-button" onclick="startRandomPractice()">ğŸ² ãƒ©ãƒ³ãƒ€ãƒ å‡ºé¡Œ</button>
          </div>
        </div>
      </div>
       
      <div class="control-group">
        <h3 class="section-title" onclick="toggleSection('levelup-practice-list', this)" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
          Lvã‚¢ãƒƒãƒ—ä½œå›³ç·´ç¿’ <span>â–¼</span>
        </h3>
        <div id="levelup-practice-list">
          <div class="btn-group-vertical">
            <button class="action-button levelup-button" onclick="startLevelUpBisector()">â‘ ç·šåˆ†ã®å‚ç›´äºŒç­‰åˆ†ç·š</button>
            <button class="action-button levelup-button" onclick="startLevelUpAngleBisector()">â‘¡è§’ã®äºŒç­‰åˆ†ç·š</button>
            <button class="action-button levelup-button" onclick="startLevelUpPerpOnLine()">â‘¢ç›´ç·šä¸Šã‚’é€šã‚‹å‚ç·š</button>
            <button class="action-button levelup-button" onclick="startLevelUpPerpOffLine()">â‘£ç›´ç·šä¸Šã«ãªã„ç‚¹ã‚’é€šã‚‹å‚ç·š</button>
          </div>
        </div>
      </div>

      <div class="control-group" id="problem-controls" style="display:none;">
         <h3 class="section-title">èª²é¡Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</h3>
         <div class="btn-group">
            <button class="action-button" id="retry-button" onclick="retryProblem()">ğŸ”„ ã‚‚ã†ä¸€åº¦</button>
            <button class="action-button" id="answer-button" onclick="showAnswer()" style="display:none;">ğŸ’¡ æ¨¡ç¯„è§£ç­”</button>
         </div>
      </div>

      <div class="credit-line">Produced by Komatsu</div>
      
    </div>

    <div id="footer-banner">
        <a href="https://sites.google.com/view/k-system-lab/ãƒ›ãƒ¼ãƒ " target="_blank">
          K-System Lab | Educational Tools & System Solutions
        </a>
    </div>

  </div>

  <div id="drawing-area">
    <div id="canvas-content">
      <canvas id="axis-canvas"></canvas>
      <canvas id="main-canvas"></canvas>
      <canvas id="overlay-canvas"></canvas>
       
      <div id="compassContainer">
        <div id="compassPivot"></div>
        <div id="compassArm">
          <div id="pencilTip" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å¹…ã‚’å¤‰ãˆã‚‹"></div>
        </div>
        <div id="pencilDrawHandle" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å††ã‚’æã">âœï¸</div>
      </div>
       
      <div id="protractorContainer">
        <div id="protractorBody">
           <canvas id="protractorCanvas" width="340" height="170"></canvas>
           <div id="protractorRotateHandle">ğŸ”ƒ</div>
        </div>
      </div>
    </div>
     
    <input type="range" id="slider-x" class="view-slider" min="-2000" max="2000" value="0">
    <input type="range" id="slider-y" class="view-slider" min="-2000" max="2000" value="0">
  </div>
<script>
    /* --- JS START --- */
    
    // â– â– â–  ã‚¨ãƒ©ãƒ¼æ¤œçŸ¥æ©Ÿèƒ½ï¼ˆã‚¢ãƒ—ãƒªãŒå‡çµã—ãŸç†ç”±ã‚’ç”»é¢ã«å‡ºã™ï¼‰ â– â– â– 
    window.onerror = function(msg, url, line) {
       alert("ã€ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿã€‘\n" + msg + "\nè¡Œç•ªå·: " + line + "\n\nã‚³ãƒ¼ãƒ‰ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã€Œå¾ŒåŠã®ã‚³ãƒ¼ãƒ‰ã€ã‚‚è²¼ã‚Šä»˜ã‘ãŸã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
       return false;
    };
    
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
     
    const axisCanvas = document.getElementById('axis-canvas');
    const axisCtx = axisCanvas.getContext('2d');
     
    // â˜…å‹•ç‚¹ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    const overlayCanvas = document.getElementById('overlay-canvas');
    const overlayCtx = overlayCanvas.getContext('2d');
     
    const drawingArea = document.getElementById('drawing-area');
    const canvasContent = document.getElementById('canvas-content');
    const imageInput = document.getElementById('image-input');
    const overlay = document.getElementById('overlay');
     
    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¦ç´ å–å¾—
    const sliderX = document.getElementById('slider-x');
    const sliderY = document.getElementById('slider-y');

    let view = { scale: 1, x: 0, y: 0 };
    let isPanning = false;
    let startPan = { x: 0, y: 0 };
    let initialPinchDist = 0;
    let initialScale = 1;
     
    let currentTool = 'point';
    let currentColor = 'black'; 
    let isDrawing = false;
    let lineStartPoint = null; 
    let history = []; 
    let redoStack = [];
    let currentProblem = null; 
     
    let movingPoints = []; 
    let isMovingPointSet = false; 
    let dragMovingPointIndex = -1; 
    let isMovingFillMode = true;
     
    // ã‚°ãƒ©ãƒ•ç®¡ç†ç”¨
    let activeGraphs = [];
    let previewGraph = null; 
    const graphColors = ['#007bff', '#28a745', '#fd7e14', '#6610f2', '#e83e8c'];

    // å†ç”Ÿç”¨
    let playbackTimer = null;
    let playbackStep = 0;
    let isPaused = false;

    // ã‚³ãƒ³ãƒ‘ã‚¹
    let compass = {
      isDragging: false, dragTarget: null, 
      pivotX: 200, pivotY: 200, radius: 100, angle: 0, 
      locked: false, centerDrawn: false
    };
     
    // â˜…åˆ†åº¦å™¨
    let protractor = {
      isDragging: false, dragTarget: null,
      x: 300, y: 300, angle: 0, 
      width: 340, height: 170
    };

    const compassContainer = document.getElementById('compassContainer');
    const compassPivot = document.getElementById('compassPivot');
    const compassArm = document.getElementById('compassArm');
    const pencilDrawHandle = document.getElementById('pencilDrawHandle');
    const pencilTip = document.getElementById('pencilTip');
    const lockButton = document.getElementById('lock-button');
    const compassControls = document.getElementById('compass-controls');
     
    // â˜…åˆ†åº¦å™¨ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆ
    const protractorContainer = document.getElementById('protractorContainer');
    const protractorBody = document.getElementById('protractorBody');
    const protractorCanvas = document.getElementById('protractorCanvas');
    const protractorRotateHandle = document.getElementById('protractorRotateHandle');
     
    const problemControls = document.getElementById('problem-controls');
    const answerButton = document.getElementById('answer-button');
    const retryButton = document.getElementById('retry-button');
     
    const setMovingButton = document.getElementById('set-moving-button');
    const movingFillContainer = document.getElementById('moving-fill-container');
    const graphControls = document.getElementById('graph-controls');

    const startReplayBtn = document.getElementById('start-replay-button');
    const playbackControls = document.getElementById('playback-controls');
    const pauseBtn = document.getElementById('pause-button');

    const labels = {
      point: document.getElementById('label-point'),
      moving_point: document.getElementById('label-moving_point'),
      line: document.getElementById('label-line'),
      ruler: document.getElementById('label-ruler'),
      compass: document.getElementById('label-compass'),
      protractor: document.getElementById('label-protractor'), 
      freehand: document.getElementById('label-freehand'),
      eraser: document.getElementById('label-eraser')
    };

    window.addEventListener('load', () => {
        try {
            initCanvasSize(); saveState(); updateCompassUI(); 
            initProtractor(); updateProtractorUI(); 
            addToolListeners(); setupImagePaste(); 
            drawingArea.addEventListener('wheel', handleWheel, { passive: false });
            window.addEventListener('resize', resizeCanvas);
            
            sliderX.addEventListener('input', handleSliderChange);
            sliderY.addEventListener('input', handleSliderChange);
        } catch(e) {
            alert("èµ·å‹•æ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
        }
    });
     
    // â˜…åˆ†åº¦å™¨ã®æç”»ï¼ˆä¸€åº¦ã ã‘å®Ÿè¡Œï¼‰
    function initProtractor() {
       const pCtx = protractorCanvas.getContext('2d');
       const w = protractorCanvas.width;
       const h = protractorCanvas.height;
       const cx = w / 2;
       const cy = h; // åº•è¾ºã®ä¸­å¤®
       const r = h - 5; // ä½™ç™½
       
       pCtx.clearRect(0, 0, w, h);
       
       // åŠå††ã®èƒŒæ™¯
       pCtx.beginPath();
       pCtx.arc(cx, cy, r, Math.PI, 0);
       pCtx.lineTo(cx, cy);
       pCtx.closePath();
       pCtx.fillStyle = "rgba(255, 255, 255, 0.6)"; // åŠé€æ˜
       pCtx.fill();
       pCtx.lineWidth = 2;
       pCtx.strokeStyle = "#333";
       pCtx.stroke();
       
       // ä¸­å¿ƒç‚¹
       pCtx.beginPath();
       pCtx.arc(cx, cy, 3, 0, Math.PI*2);
       pCtx.fillStyle = "red";
       pCtx.fill();
       
       // ç›®ç››ã‚Š
       pCtx.textAlign = "center";
       pCtx.textBaseline = "middle";
       pCtx.fillStyle = "black";
       
       for(let i = 0; i <= 180; i++) {
          const rad = (Math.PI / 180) * (180 - i);
          const cos = Math.cos(rad);
          const sin = Math.sin(rad);
          
          let len = 5;
          if (i % 10 === 0) len = 15;
          else if (i % 5 === 0) len = 10;
          
          // å¤–å´ã®ç·š
          pCtx.beginPath();
          pCtx.moveTo(cx + (r - len) * cos, cy - (r - len) * sin);
          pCtx.lineTo(cx + r * cos, cy - r * sin);
          pCtx.stroke();
          
          // æ•°å­—
          if (i % 10 === 0) {
             // å¤–å´ã®æ•°å­— (0 -> 180)
             pCtx.font = "bold 12px Arial";
             pCtx.fillText(i, cx + (r - 28) * cos, cy - (r - 28) * sin);
             
             // å†…å´ã®æ•°å­— (180 -> 0)
             pCtx.font = "10px Arial";
             pCtx.fillStyle = "#555";
             pCtx.fillText(180 - i, cx + (r - 45) * cos, cy - (r - 45) * sin);
             pCtx.fillStyle = "black";
          }
       }
    }
     
    function updateProtractorUI() {
       const left = protractor.x - (protractor.width / 2);
       const top = protractor.y - protractor.height;
       
       protractorBody.style.left = left + 'px';
       protractorBody.style.top = top + 'px';
       protractorBody.style.transform = `rotate(${protractor.angle * 180 / Math.PI}deg)`;
    }

    function toggleSection(id, element) {
      const content = document.getElementById(id);
      const icon = element.querySelector('span');
      if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.innerText = 'â–¼';
      } else {
        content.style.display = 'none';
        icon.innerText = 'â–²';
      }
    }

    function initCanvasSize() {
      const rect = drawingArea.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      axisCanvas.width = rect.width;
      axisCanvas.height = rect.height;
      overlayCanvas.width = rect.width;
      overlayCanvas.height = rect.height;
       
      canvasContent.style.width = rect.width + 'px';
      canvasContent.style.height = rect.height + 'px';
       
      compass.pivotX = rect.width / 2;
      compass.pivotY = rect.height / 2;
       
      // åˆ†åº¦å™¨ã‚‚ä¸­å¤®ã¸
      protractor.x = rect.width / 2;
      protractor.y = rect.height / 2;
       
      if(document.getElementById('axis-toggle').checked) {
          drawAxis();
      }
       
      if (history.length > 0) restoreState(history[history.length - 1]);
    }
     
    function resizeCanvas() {
       if (history.length > 0) {
          const rect = drawingArea.getBoundingClientRect();
          
          canvas.width = rect.width;
          canvas.height = rect.height;
          axisCanvas.width = rect.width;
          axisCanvas.height = rect.height;
          overlayCanvas.width = rect.width;
          overlayCanvas.height = rect.height;
          
          canvasContent.style.width = rect.width + 'px';
          canvasContent.style.height = rect.height + 'px';

          restoreState(history[history.length - 1]);
          drawMovingPoints();
          
          if(document.getElementById('axis-toggle').checked) {
             drawAxis();
          }
       } else {
          initCanvasSize();
       }
    }

    function handleSliderChange() {
       view.x = -parseInt(sliderX.value, 10);
       view.y = -parseInt(sliderY.value, 10);
       updateTransform();
    }

    function updateTransform() {
      canvasContent.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
      sliderX.value = -view.x;
      sliderY.value = -view.y;
    }
     
    function resetView() { 
       view = { scale: 1, x: 0, y: 0 }; 
       updateTransform(); 
    }

    function handleWheel(e) {
      if (!e.ctrlKey && !e.metaKey) { e.preventDefault(); }
      const rect = drawingArea.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const newScale = view.scale * zoomFactor;
      if (newScale < 0.5 || newScale > 5.0) return;
      view.x = mouseX - (mouseX - view.x) * (newScale / view.scale);
      view.y = mouseY - (mouseY - view.y) * (newScale / view.scale);
      view.scale = newScale;
      updateTransform();
    }

    function getEventPos(e) {
      const rect = drawingArea.getBoundingClientRect();
      let cx, cy;
      if (e.touches && e.touches.length > 0) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; } 
      else { cx = e.clientX; cy = e.clientY; }
      const screenX = cx - rect.left;
      const screenY = cy - rect.top;
      return { x: (screenX - view.x) / view.scale, y: (screenY - view.y) / view.scale };
    }

    function setTool(newTool) {
      if (currentTool === 'moving_point' && newTool !== 'moving_point') {
         isMovingPointSet = false;
         dragMovingPointIndex = -1;
         updateMovingButtonUI(); 
      }
       
      currentTool = newTool;
      lineStartPoint = null;
       
      if (currentTool === 'moving_point') {
        setMovingButton.style.display = 'block';
        movingFillContainer.style.display = 'flex'; 
        if (movingPoints.length > 0) {
           isMovingPointSet = true;
        } else {
           isMovingPointSet = false;
        }
        updateMovingButtonUI();
        drawMovingPoints();
      } else {
        setMovingButton.style.display = 'none';
        movingFillContainer.style.display = 'none'; 
      }
       
      // ã‚³ãƒ³ãƒ‘ã‚¹
      if (currentTool === 'compass') {
        compassContainer.style.display = 'block'; compassControls.style.display = 'block'; lockButton.style.display = 'block';
        compass.radius = 100; compass.locked = false; updateLockUI(); updateCompassUI();
      } else {
        compassContainer.style.display = 'none'; compassControls.style.display = 'none';
      }
       
      // â˜…åˆ†åº¦å™¨
      if (currentTool === 'protractor') {
         protractorContainer.style.display = 'block';
         updateProtractorUI();
      } else {
         protractorContainer.style.display = 'none';
      }
       
      updateCursor();
    }

    function toggleMovingSet() {
      isMovingPointSet = !isMovingPointSet;
      updateMovingButtonUI();
    }
     
    function toggleMovingFill() {
      isMovingFillMode = document.getElementById('moving-fill-toggle').checked;
      drawMovingPoints();
    }
     
    function toggleGrid() {
      const isGrid = document.getElementById('grid-toggle').checked;
      if (isGrid) {
        canvasContent.classList.add('grid-background');
      } else {
        canvasContent.classList.remove('grid-background');
      }
    }
     
    function toggleAxis() {
      const isAxis = document.getElementById('axis-toggle').checked;
      if (isAxis) {
        axisCanvas.style.display = 'block';
        graphControls.style.display = 'flex'; 
        drawAxis(); 
      } else {
        axisCanvas.style.display = 'none';
        graphControls.style.display = 'none';
      }
    }
     
    function parseMathInput(val) {
      if (typeof val !== 'string') return parseFloat(val) || 0;
      val = val.trim();
      if (val === '') return 0;
      if (val.includes('/')) {
        const parts = val.split('/');
        if (parts.length === 2) {
          const numerator = parseFloat(parts[0]);
          const denominator = parseFloat(parts[1]);
          if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
            return numerator / denominator;
          }
        }
      }
      return parseFloat(val) || 0;
    }
     
    function updatePolyPreview() {
      const a = parseMathInput(document.getElementById('poly-a').value);
      const b = parseMathInput(document.getElementById('poly-b').value);
      const c = parseMathInput(document.getElementById('poly-c').value);
      const d = parseMathInput(document.getElementById('poly-d').value);
      previewGraph = { type: 'poly', a:a, b:b, c:c, d:d, color: '#999', isPreview: true };
      drawAxis();
    }
     
    function addPolyGraph() {
      const a = parseMathInput(document.getElementById('poly-a').value);
      const b = parseMathInput(document.getElementById('poly-b').value);
      const c = parseMathInput(document.getElementById('poly-c').value);
      const d = parseMathInput(document.getElementById('poly-d').value);
      const color = graphColors[activeGraphs.length % graphColors.length];
      activeGraphs.push({ type: 'poly', a:a, b:b, c:c, d:d, color: color });
      previewGraph = null;
      drawAxis();
    }
     
    function clearGraphs() {
      activeGraphs = [];
      previewGraph = null;
      drawAxis();
    }
     
    function drawAxis() {
      const w = axisCanvas.width;
      const h = axisCanvas.height;
      const cx = w / 2;
      const cy = h / 2;
      const gridSize = 25; 
       
      axisCtx.clearRect(0, 0, w, h);
       
      axisCtx.strokeStyle = "#e0e0e0";
      axisCtx.lineWidth = 1;
      axisCtx.beginPath();
      for (let x = cx; x < w; x += gridSize) { axisCtx.moveTo(x, 0); axisCtx.lineTo(x, h); }
      for (let x = cx; x > 0; x -= gridSize) { axisCtx.moveTo(x, 0); axisCtx.lineTo(x, h); }
      for (let y = cy; y < h; y += gridSize) { axisCtx.moveTo(0, y); axisCtx.lineTo(w, y); }
      for (let y = cy; y > 0; y -= gridSize) { axisCtx.moveTo(0, y); axisCtx.lineTo(w, y); }
      axisCtx.stroke();
       
      axisCtx.strokeStyle = "#444";
      axisCtx.lineWidth = 1.5;
      axisCtx.fillStyle = "#444";
      axisCtx.font = "italic 16px Arial";
       
      axisCtx.beginPath(); axisCtx.moveTo(0, cy); axisCtx.lineTo(w, cy); axisCtx.stroke();
      axisCtx.beginPath(); axisCtx.moveTo(w, cy); axisCtx.lineTo(w - 10, cy - 5); axisCtx.lineTo(w - 10, cy + 5); axisCtx.fill();
      axisCtx.fillText("x", w - 20, cy + 20);
       
      axisCtx.beginPath(); axisCtx.moveTo(cx, 0); axisCtx.lineTo(cx, h); axisCtx.stroke();
      axisCtx.beginPath(); axisCtx.moveTo(cx, 0); axisCtx.lineTo(cx - 5, 10); axisCtx.lineTo(cx + 5, 10); axisCtx.fill();
      axisCtx.fillText("y", cx - 20, 15);
      axisCtx.fillText("O", cx - 15, cy + 20);
       
      drawGraphs(cx, cy, gridSize);
    }
     
    function drawGraphs(cx, cy, unit) {
      activeGraphs.forEach(g => drawSingleGraph(g, cx, cy, unit));
      if (previewGraph) {
         drawSingleGraph(previewGraph, cx, cy, unit);
      }
    }
     
    function drawSingleGraph(g, cx, cy, unit) {
      axisCtx.beginPath();
      axisCtx.strokeStyle = g.color;
      axisCtx.lineWidth = 2;
       
      if (g.isPreview) axisCtx.setLineDash([5, 5]); 
      else axisCtx.setLineDash([]); 
       
      if (g.type === 'poly') {
        let first = true;
        for(let px = 0; px <= axisCanvas.width; px += 2) {
           const mx = (px - cx) / unit;
           const my = g.a * Math.pow(mx, 3) + g.b * Math.pow(mx, 2) + g.c * mx + g.d;
           const py = cy - my * unit;
           
           if(first) { axisCtx.moveTo(px, py); first = false; }
           else { axisCtx.lineTo(px, py); }
        }
      }
      axisCtx.stroke();
      axisCtx.setLineDash([]); 
    }

    function updateMovingButtonUI() {
      if (isMovingPointSet) {
        setMovingButton.textContent = "å‹•ç‚¹ã‚’è§£é™¤";
        setMovingButton.classList.add('is-active');
      } else {
        setMovingButton.textContent = "ã‚»ãƒƒãƒˆï¼ˆç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã¸ï¼‰";
        setMovingButton.classList.remove('is-active');
      }
    }

    function setColor(color) { currentColor = color; }
    function updateCursor() { canvas.style.cursor = (currentTool === 'freehand' || currentTool === 'point' || currentTool === 'moving_point' || currentTool === 'eraser') ? 'crosshair' : 'default'; }

    // â˜…â˜…â˜… ä½œå›³ãƒ¢ãƒ¼ãƒ‰æ™‚ã«åˆ†åº¦å™¨ã‚‚éš ã™ã‚ˆã†ã«ä¿®æ­£ â˜…â˜…â˜…
    function toggleDrawingMode() {
      const isMode = document.getElementById('mode-toggle').checked;
      if (isMode) {
        labels.point.style.display = 'none'; 
        labels.moving_point.style.display = 'none';
        labels.line.style.display = 'none'; 
        labels.freehand.style.display = 'none';
        labels.eraser.style.display = 'none'; 
        labels.protractor.style.display = 'none'; // â˜…ã“ã“ã‚’è¿½åŠ ï¼ˆåˆ†åº¦å™¨ã‚’éš ã™ï¼‰

        // ã‚‚ã—éš ã•ã‚Œã‚‹ãƒ„ãƒ¼ãƒ«ã‚’é¸æŠä¸­ã ã£ãŸå ´åˆã€å®šè¦ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
        // â˜…é…åˆ—ã« 'protractor' ã‚’è¿½åŠ ã—ã¾ã—ãŸ
        if (['point','moving_point','line','freehand','eraser', 'protractor'].includes(currentTool)) {
          document.querySelector('input[value="ruler"]').checked = true; setTool('ruler');
        }
      } else {
        labels.point.style.display = 'flex'; 
        labels.moving_point.style.display = 'flex';
        labels.line.style.display = 'flex'; 
        labels.freehand.style.display = 'flex';
        labels.eraser.style.display = 'flex';
        labels.protractor.style.display = 'flex'; // â˜…ã“ã“ã‚’è¿½åŠ ï¼ˆåˆ†åº¦å™¨ã‚’è¡¨ç¤ºï¼‰
      }
    }

    function toggleCompassLock() { compass.locked = !compass.locked; updateLockUI(); }
    function updateLockUI() {
      if (compass.locked) {
        lockButton.classList.add('is-locked'); lockButton.textContent = 'ãƒ­ãƒƒã‚¯è§£é™¤'; 
        pencilTip.classList.add('locked'); pencilTip.title = "è§’åº¦ã®ã¿èª¿æ•´ï¼ˆæç”»ãªã—ï¼‰";
      } else {
        lockButton.classList.remove('is-locked'); lockButton.textContent = 'å¹…ã‚’ãƒ­ãƒƒã‚¯'; 
        pencilTip.classList.remove('locked'); pencilTip.title = "å¹…ã¨è§’åº¦ã‚’èª¿æ•´";
      }
    }

    function startPlayback() {
      if (history.length <= 1) return;
      startReplayBtn.style.display = 'none';
      playbackControls.style.display = 'flex';
      overlay.style.display = 'block'; 
      playbackStep = 0; isPaused = false; pauseBtn.textContent = 'â¸ ä¸€æ™‚åœæ­¢';
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      loopFunction();
    }
    function loopFunction() {
      if (isPaused) return;
      if (playbackStep < history.length) {
        restoreState(history[playbackStep]);
        playbackStep++;
        playbackTimer = setTimeout(loopFunction, 800); 
      } else {
        playbackTimer = setTimeout(() => {
           if (isPaused) return;
           playbackStep = 0;
           ctx.clearRect(0, 0, canvas.width, canvas.height); 
           playbackTimer = setTimeout(loopFunction, 500); 
        }, 2000); 
      }
    }
    function togglePause() {
      if (isPaused) { isPaused = false; pauseBtn.textContent = 'â¸ ä¸€æ™‚åœæ­¢'; loopFunction(); } 
      else { isPaused = true; pauseBtn.textContent = 'â–¶ å†é–‹'; clearTimeout(playbackTimer); }
    }
    function stopPlayback() {
      clearTimeout(playbackTimer); isPaused = false;
      restoreState(history[history.length - 1]);
      overlay.style.display = 'none'; playbackControls.style.display = 'none'; startReplayBtn.style.display = 'block';
    }

    function startRandomPractice() { startPractice(Math.floor(Math.random() * 4) + 1); }
    function retryProblem() {
      if (!currentProblem) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      history = []; redoStack = []; lineStartPoint = null;
      if (currentProblem.type.toString().startsWith('levelup_')) drawLevelUpProblem(currentProblem);
      else drawProblem(currentProblem);
      saveState();
    }
     
    function generateCompactTriangle(w, h) {
      const cx = w / 2, cy = h / 2;
      const radius = 120 + Math.random() * 80;
      const angleA = Math.random() * Math.PI * 2;
      const Ax = cx + radius * Math.cos(angleA), Ay = cy + radius * Math.sin(angleA);
      const angleB = angleA + (Math.PI * 2 / 3) + (Math.random() * 0.5 - 0.25);
      const Bx = cx + radius * Math.cos(angleB), By = cy + radius * Math.sin(angleB);
      const angleC = angleA + (Math.PI * 4 / 3) + (Math.random() * 0.5 - 0.25);
      const Cx = cx + radius * Math.cos(angleC), Cy = cy + radius * Math.sin(angleC);
      return { A: { x: Ax, y: Ay }, B: { x: Bx, y: By }, C: { x: Cx, y: Cy } };
    }
     
    // â˜…â˜…â˜… Lvã‚¢ãƒƒãƒ—å•é¡Œ1ï¼šä¸‰è§’å½¢ã®å‚ç›´äºŒç­‰åˆ†ç·šï¼ˆã€Œç·šåˆ†ã€ã«ä¿®æ­£ï¼‰ â˜…â˜…â˜…
    function startLevelUpBisector() {
      setupLevelUpProblem();
      const tri = generateCompactTriangle(canvas.width, canvas.height);
      const questions = [
        { text: "ç·šåˆ†ABã®å‚ç›´äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„", p1: tri.A, p2: tri.B },
        { text: "ç·šåˆ†BCã®å‚ç›´äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„", p1: tri.B, p2: tri.C },
        { text: "ç·šåˆ†CAã®å‚ç›´äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„", p1: tri.C, p2: tri.A }
      ];
      const selected = questions[Math.floor(Math.random() * 3)];
      currentProblem = { type: 'levelup_bisector', A: tri.A, B: tri.B, C: tri.C, questionText: selected.text, targetP1: selected.p1, targetP2: selected.p2 };
      drawLevelUpProblem(currentProblem); saveState();
    }
     
    function startLevelUpAngleBisector() {
      setupLevelUpProblem();
      const tri = generateCompactTriangle(canvas.width, canvas.height);
      const questions = [
        { text: "âˆ BACã®äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„", O: tri.A, arm1: tri.B, arm2: tri.C },
        { text: "âˆ ABCã®äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„", O: tri.B, arm1: tri.A, arm2: tri.C },
        { text: "âˆ BCAã®äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„", O: tri.C, arm1: tri.A, arm2: tri.B }
      ];
      const selected = questions[Math.floor(Math.random() * 3)];
      currentProblem = { type: 'levelup_angle_bisector', A: tri.A, B: tri.B, C: tri.C, questionText: selected.text, targetO: selected.O, targetArm1: selected.arm1, targetArm2: selected.arm2 };
      drawLevelUpProblem(currentProblem); saveState();
    }
    function startLevelUpPerpOnLine() {
      setupLevelUpProblem();
      const tri = generateCompactTriangle(canvas.width, canvas.height);
      const sides = [{ p1: tri.A, p2: tri.B }, { p1: tri.B, p2: tri.C }, { p1: tri.C, p2: tri.A }];
      const s = sides[Math.floor(Math.random() * 3)];
      const t = 0.3 + Math.random() * 0.4;
      const P = { x: s.p1.x + (s.p2.x - s.p1.x) * t, y: s.p1.y + (s.p2.y - s.p1.y) * t };
      const angle = Math.atan2(s.p2.y - s.p1.y, s.p2.x - s.p1.x);
      currentProblem = { type: 'levelup_perp_online', A: tri.A, B: tri.B, C: tri.C, P: P, lineAngle: angle, questionText: "ç‚¹Pã®å‚ç·šã‚’ä½œå›³ã—ãªã•ã„" };
      drawLevelUpProblem(currentProblem); saveState();
    }
    // â˜…â˜…â˜… Lvã‚¢ãƒƒãƒ—å•é¡Œ4ï¼šç›´ç·šä¸Šã«ãªã„ç‚¹ã‚’é€šã‚‹å‚ç·š (æ–°è¦) â˜…â˜…â˜…
    function startLevelUpPerpOffLine() {
      setupLevelUpProblem();
      const tri = generateCompactTriangle(canvas.width, canvas.height);
      const q = [
        { text: "ç‚¹Aã‹ã‚‰ç›´ç·šBCã«å‚ç·šã‚’å¼•ããªã•ã„", P: tri.A, s: tri.B, e: tri.C },
        { text: "ç‚¹Bã‹ã‚‰ç›´ç·šACã«å‚ç·šã‚’å¼•ããªã•ã„", P: tri.B, s: tri.A, e: tri.C },
        { text: "ç‚¹Cã‹ã‚‰ç›´ç·šABã«å‚ç·šã‚’å¼•ããªã•ã„", P: tri.C, s: tri.A, e: tri.B }
      ];
      const selected = q[Math.floor(Math.random() * 3)];
      const angle = Math.atan2(selected.e.y - selected.s.y, selected.e.x - selected.s.x);
      currentProblem = { type: 'levelup_perp_offline', A: tri.A, B: tri.B, C: tri.C, P: selected.P, lineP: selected.s, lineAngle: angle, questionText: selected.text };
      drawLevelUpProblem(currentProblem); saveState();
    }
     
    function setupLevelUpProblem() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); history = []; redoStack = []; lineStartPoint = null;
      problemControls.style.display = 'block'; answerButton.style.display = 'block'; retryButton.style.display = 'block';
    }
    function drawLevelUpProblem(p) {
      const savedColor = currentColor; currentColor = 'black'; ctx.fillStyle = "black"; ctx.font = "20px Arial";
      ctx.fillText(p.questionText, 30, 50);
      drawLine(p.A.x, p.A.y, p.B.x, p.B.y, 'line'); drawLine(p.B.x, p.B.y, p.C.x, p.C.y, 'line'); drawLine(p.C.x, p.C.y, p.A.x, p.A.y, 'line');
      drawPoint(p.A.x, p.A.y); drawPoint(p.B.x, p.B.y); drawPoint(p.C.x, p.C.y);
      ctx.fillStyle = "black"; ctx.font = "bold 24px Arial";
      ctx.fillText("A", p.A.x-10, p.A.y-15); ctx.fillText("B", p.B.x-25, p.B.y+10); ctx.fillText("C", p.C.x+10, p.C.y+10);
      if (p.type === 'levelup_perp_online') { drawPoint(p.P.x, p.P.y); ctx.fillText("P", p.P.x+15, p.P.y-15); }
      currentColor = savedColor;
    }

    function startPractice(type) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      history = []; redoStack = []; lineStartPoint = null;
      const w = canvas.width, h = canvas.height;
      let problem = { type: type };
      if (type === 1) { 
        let A, B, valid=false;
        while(!valid) {
             A={x:60+Math.random()*(w-120), y:80+Math.random()*(h-140)};
             const ang=Math.random()*Math.PI*2, len=150+Math.random()*200;
             B={x:A.x+len*Math.cos(ang), y:A.y+len*Math.sin(ang)};
             if(B.x>60 && B.x<w-60 && B.y>80 && B.y<h-60) valid=true;
        }
        problem.A=A; problem.B=B;
      } else if (type === 2) { 
        problem.O = {x:w/2+(Math.random()-0.5)*100, y:h/2+(Math.random()-0.5)*100};
        problem.baseAngle=Math.random()*Math.PI*2; problem.openAngle=(40+Math.random()*100)*(Math.PI/180); problem.len=Math.max(w,h)*0.7;
      } else if (type === 3) { 
        const ang=(Math.random()*30-15)*(Math.PI/180), cx=w/2, cy=h/2+50, len=Math.min(w,h)*0.85;
        const x1=cx-(len/2)*Math.cos(ang), y1=cy-(len/2)*Math.sin(ang), x2=cx+(len/2)*Math.cos(ang), y2=cy+(len/2)*Math.sin(ang);
        const t=0.35+Math.random()*0.3;
        problem.P={x:x1+(x2-x1)*t, y:y1+(y2-y1)*t}; problem.lineStart={x:x1,y:y1}; problem.lineEnd={x:x2,y:y2}; problem.lineAngle=ang;
      } else if (type === 4) { 
        const ang=(Math.random()*20-10)*(Math.PI/180), cx=w/2, cy=h*0.7, len=Math.min(w,h)*0.85;
        const x1=cx-(len/2)*Math.cos(ang), y1=cy-(len/2)*Math.sin(ang), x2=cx+(len/2)*Math.cos(ang), y2=cy+(len/2)*Math.sin(ang);
        const t=0.4+Math.random()*0.2, bx=x1+(x2-x1)*t, by=y1+(y2-y1)*t;
        const pDist=120+Math.random()*60, pAng=ang-Math.PI/2;
        problem.P={x:bx+pDist*Math.cos(pAng), y:by+pDist*Math.sin(pAng)}; problem.lineP={x:bx,y:by};
        problem.lineStart={x:x1,y:y1}; problem.lineEnd={x:x2,y:y2}; problem.lineAngle=ang;
      }
      currentProblem = problem; drawProblem(currentProblem); saveState();
      problemControls.style.display = 'block'; answerButton.style.display = 'block'; retryButton.style.display = 'block'; 
    }

    function drawProblem(p) {
      const savedColor = currentColor; currentColor = 'black'; ctx.fillStyle = "black"; ctx.font = "20px Arial";
      if (p.type === 1) {
        ctx.fillText("ç·šåˆ† AB ã®å‚ç›´äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„", 30, 50);
        drawLine(p.A.x, p.A.y, p.B.x, p.B.y, 'segment'); 
        ctx.fillStyle = "black"; ctx.fillText("A", p.A.x-15, p.A.y+25); ctx.fillText("B", p.B.x-15, p.B.y+25);
      } else if (p.type === 2) {
        ctx.fillText("âˆ O ã®äºŒç­‰åˆ†ç·šã‚’ä½œå›³ã—ãªã•ã„", 30, 50);
        const O=p.O, len=p.len, Xx=O.x+len*Math.cos(p.baseAngle), Xy=O.y+len*Math.sin(p.baseAngle);
        const Yx=O.x+len*Math.cos(p.baseAngle+p.openAngle), Yy=O.y+len*Math.sin(p.baseAngle+p.openAngle);
        ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle="black"; ctx.moveTo(Xx, Xy); ctx.lineTo(O.x, O.y); ctx.lineTo(Yx, Yy); ctx.stroke();
        const ld=25, ca=p.baseAngle+p.openAngle/2+Math.PI; ctx.fillStyle="black"; ctx.fillText("O", O.x+ld*Math.cos(ca)-6, O.y+ld*Math.sin(ca)+6);
      } else if (p.type === 3 || p.type === 4) {
        ctx.fillText("ç‚¹ P ã‚’é€šã‚‹å‚ç·šã‚’ä½œå›³ã—ãªã•ã„", 30, 50);
        drawLine(p.lineStart.x, p.lineStart.y, p.lineEnd.x, p.lineEnd.y, 'segment');
        drawPoint(p.P.x, p.P.y);
        ctx.fillStyle = "black"; ctx.fillText("X", p.lineStart.x+5, p.lineStart.y-10); ctx.fillText("Y", p.lineEnd.x-15, p.lineEnd.y-10); 
        ctx.fillText("P", p.P.x-5, p.type===3?p.P.y+25:p.P.y-15);
      }
      currentColor = savedColor;
    }

    function showAnswer() {
      if (!currentProblem) return;
      saveState(); 
      const savedColor = currentColor;
      const stepColors = ['black', '#007bff', '#dc3545'];
      let stepCount = 0;
      function drawDoubleSmartArc(center, r, angle1, angle2) {
        const color = stepColors[stepCount % 3]; const num = stepCount + 1;
        drawPoint(center.x, center.y, color, 6); 
        ctx.fillStyle = color; ctx.font = "bold 24px Arial"; ctx.fillText(num, center.x - 15, center.y - 15); 
        ctx.strokeStyle = color; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(center.x, center.y, r, angle1 - 0.4, angle1 + 0.4); ctx.stroke();
        ctx.beginPath(); ctx.arc(center.x, center.y, r, angle2 - 0.4, angle2 + 0.4); ctx.stroke();
        stepCount++;
      }
      function drawSmartArc(center, r, targetAngle) {
        const color = stepColors[stepCount % 3]; const num = stepCount + 1;
        drawPoint(center.x, center.y, color, 6); 
        ctx.fillStyle = color; ctx.font = "bold 24px Arial"; ctx.fillText(num, center.x - 15, center.y - 15); 
        ctx.strokeStyle = color; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(center.x, center.y, r, targetAngle - 0.4, targetAngle + 0.4); ctx.stroke();
        stepCount++;
      }
      const tasks = [];
      const originalDouble = drawDoubleSmartArc, originalSingle = drawSmartArc;
      drawDoubleSmartArc = (c, r, a1, a2) => tasks.push(() => originalDouble(c, r, a1, a2));
      drawSmartArc = (c, r, a) => tasks.push(() => originalSingle(c, r, a));

      if (currentProblem.type === 1 || currentProblem.type === 'levelup_bisector') {
          const A = (currentProblem.type === 'levelup_bisector') ? currentProblem.targetP1 : currentProblem.A;
          const B = (currentProblem.type === 'levelup_bisector') ? currentProblem.targetP2 : currentProblem.B;
          const dist = Math.hypot(B.x - A.x, B.y - A.y), r = dist * 0.7, angleAB = Math.atan2(B.y - A.y, B.x - A.x), delta = Math.acos((dist/2)/r);
          drawDoubleSmartArc(A, r, angleAB + delta, angleAB - delta); drawDoubleSmartArc(B, r, angleAB + Math.PI - delta, angleAB + Math.PI + delta);
          tasks.push(() => {
            const midX=(A.x+B.x)/2, midY=(A.y+B.y)/2, perpAngle=angleAB+Math.PI/2, len=1000;
            ctx.strokeStyle="#dc3545"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(midX-len*Math.cos(perpAngle), midY-len*Math.sin(perpAngle)); ctx.lineTo(midX+len*Math.cos(perpAngle), midY+len*Math.sin(perpAngle)); ctx.stroke();
          });
      } else if (currentProblem.type === 2 || currentProblem.type === 'levelup_angle_bisector') {
          let O, P1, P2;
          if(currentProblem.type===2) { O=currentProblem.O; P1={x:O.x+80*Math.cos(currentProblem.baseAngle), y:O.y+80*Math.sin(currentProblem.baseAngle)}; P2={x:O.x+80*Math.cos(currentProblem.baseAngle+currentProblem.openAngle), y:O.y+80*Math.sin(currentProblem.baseAngle+currentProblem.openAngle)}; }
          else { O=currentProblem.targetO; P1=currentProblem.targetArm1; P2=currentProblem.targetArm2; }
          const r1=80, a1=Math.atan2(P1.y-O.y, P1.x-O.x), a2=Math.atan2(P2.y-O.y, P2.x-O.x);
          drawDoubleSmartArc(O, r1, a1, a2);
          const c1={x:O.x+r1*Math.cos(a1), y:O.y+r1*Math.sin(a1)}, c2={x:O.x+r1*Math.cos(a2), y:O.y+r1*Math.sin(a2)};
          const bisectorAngle = Math.atan2(Math.sin(a1)+Math.sin(a2), Math.cos(a1)+Math.cos(a2));
          const r2=80, h_tri=Math.sqrt(r2*r2-(Math.hypot(c2.x-c1.x,c2.y-c1.y)/2)**2), tx=(c1.x+c2.x)/2+h_tri*Math.cos(bisectorAngle), ty=(c1.y+c2.y)/2+h_tri*Math.sin(bisectorAngle);
          drawSmartArc(c1, r2, Math.atan2(ty-c1.y, tx-c1.x)); drawSmartArc(c2, r2, Math.atan2(ty-c2.y, tx-c2.x));
          tasks.push(() => { ctx.strokeStyle="#dc3545"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(O.x,O.y); ctx.lineTo(O.x+1000*Math.cos(bisectorAngle),O.y+1000*Math.sin(bisectorAngle)); ctx.stroke(); });
          
      } else if (currentProblem.type === 'levelup_perp_online' || currentProblem.type === 3) {
          const P = currentProblem.P, ang = currentProblem.lineAngle, r1=60;
          const i1={x:P.x+r1*Math.cos(ang), y:P.y+r1*Math.sin(ang)}, i2={x:P.x-r1*Math.cos(ang), y:P.y-r1*Math.sin(ang)};
          drawDoubleSmartArc(P, r1, ang, ang+Math.PI);
          const r2=80, pAng=ang+Math.PI/2, h=Math.sqrt(r2*r2-r1*r1), c={x:P.x+h*Math.cos(pAng), y:P.y+h*Math.sin(pAng)};
          drawSmartArc(i1, r2, Math.atan2(c.y-i1.y, c.x-i1.x)); drawSmartArc(i2, r2, Math.atan2(c.y-i2.y, c.x-i2.x));
          tasks.push(()=>{ ctx.strokeStyle="#dc3545"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(P.x-1000*Math.cos(pAng), P.y-1000*Math.sin(pAng)); ctx.lineTo(P.x+1000*Math.cos(pAng), P.y+1000*Math.sin(pAng)); ctx.stroke(); });
          
      } else if (currentProblem.type === 'levelup_perp_offline' || currentProblem.type === 4) {
          const P = currentProblem.P;
          const baseP = currentProblem.lineP; 
          const ang = currentProblem.lineAngle;
          const dist = Math.hypot(P.x-baseP.x, P.y-baseP.y);
          const R1 = dist * 1.3;
          const vx=baseP.x-P.x, vy=baseP.y-P.y, ux=Math.cos(ang), uy=Math.sin(ang);
          const B=2*(vx*ux+vy*uy), C=(vx*vx+vy*vy)-R1*R1, det=B*B-4*C, t1=(-B+Math.sqrt(det))/2, t2=(-B-Math.sqrt(det))/2;
          const I1={x:baseP.x+t1*ux, y:baseP.y+t1*uy}, I2={x:baseP.x+t2*ux, y:baseP.y+t2*uy};
          drawDoubleSmartArc(P, R1, Math.atan2(I1.y-P.y,I1.x-P.x), Math.atan2(I2.y-P.y,I2.x-P.x));
          const R2=R1*1.1;
          const mx=(I1.x+I2.x)/2, my=(I1.y+I2.y)/2;
          const distM=Math.sqrt(R2*R2-(Math.hypot(I1.x-I2.x,I1.y-I2.y)/2)**2);
          let nAng=ang+Math.PI/2; 
          if(Math.hypot(mx+Math.cos(nAng)-P.x, my+Math.sin(nAng)-P.y) < Math.hypot(mx-Math.cos(nAng)-P.x, my-Math.sin(nAng)-P.y)) {
              nAng-=Math.PI;
          }
          const TX={x:mx+distM*Math.cos(nAng), y:my+distM*Math.sin(nAng)};
          drawSmartArc(I1, R2, Math.atan2(TX.y-I1.y,TX.x-I1.x)); 
          drawSmartArc(I2, R2, Math.atan2(TX.y-I2.y,TX.x-I2.x));
          tasks.push(()=>{ 
              ctx.strokeStyle="#dc3545"; ctx.lineWidth=3; ctx.beginPath(); 
              const dx=TX.x-P.x, dy=TX.y-P.y, l=Math.hypot(dx,dy);
              ctx.moveTo(P.x-(dx/l)*2000, P.y-(dy/l)*2000); 
              ctx.lineTo(P.x+(dx/l)*2000, P.y+(dy/l)*2000); 
              ctx.stroke();
          });
      }
      overlay.style.display = 'block';
      let i = 0;
      function run() {
        if (i < tasks.length) { tasks[i](); i++; setTimeout(run, 800); } 
        else { overlay.style.display = 'none'; saveState(); currentColor = savedColor; }
      }
      run();
    }

    imageInput.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) { handleImageFile(file); imageInput.value = ''; }
    });
    function setupImagePaste() {
      window.addEventListener('paste', function(e) {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf('image') !== -1) { handleImageFile(items[i].getAsFile()); e.preventDefault(); break; }
        }
      });
    }
    function handleImageFile(file) {
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          let dw = img.width, dh = img.height;
          const mw = canvas.width * 0.8, mh = canvas.height * 0.8;
          if (dw > mw || dh > mh) { const r = Math.min(mw / dw, mh / dh); dw *= r; dh *= r; }
          ctx.drawImage(img, (canvas.width - dw)/2, (canvas.height - dh)/2, dw, dh);
          saveState();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }

    function saveState() { redoStack = []; history.push(canvas.toDataURL()); if (history.length > 30) history.shift(); }
    function restoreState(dataURL) {
        const img = new Image();
        img.onload = function() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); };
        img.src = dataURL;
    }
     
    function undoAction() {
      if (currentTool === 'moving_point') {
        if (isMovingPointSet) { toggleMovingSet(); return; }
        if (movingPoints.length > 0) { movingPoints.pop(); drawMovingPoints(); return; }
      }
      if (history.length > 1) { 
        redoStack.push(history.pop()); restoreState(history[history.length - 1]); 
        if (currentTool === 'moving_point') { movingPoints = []; }
        lineStartPoint = null; 
      }
    }
     
    function redoAction() { if (redoStack.length > 0) { const next = redoStack.pop(); history.push(next); restoreState(next); lineStartPoint = null; } }
    function resetCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); history = []; redoStack = []; saveState(); lineStartPoint = null;
      currentProblem = null; problemControls.style.display = 'none';
      movingPoints = []; 
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      resetView(); 
    }

    // --- ã‚³ãƒ³ãƒ‘ã‚¹UI ---
    function updateCompassUI() {
      compassPivot.style.left = compass.pivotX + 'px';
      compassPivot.style.top = compass.pivotY + 'px';
      compassArm.style.left = compass.pivotX + 'px';
      compassArm.style.top = compass.pivotY + 'px';
      compassArm.style.width = compass.radius + 'px';
      compassArm.style.transform = `rotate(${compass.angle * 180 / Math.PI}deg)`;
      const pencilOffset = 40; 
      const pencilX = compass.pivotX + (compass.radius + pencilOffset) * Math.cos(compass.angle);
      const pencilY = compass.pivotY + (compass.radius + pencilOffset) * Math.sin(compass.angle);
      pencilDrawHandle.style.left = pencilX + 'px';
      pencilDrawHandle.style.top = pencilY + 'px';
      pencilDrawHandle.style.transform = `translate(-50%, -50%)`;
    }

    function startCompassDrag(e) {
      if (currentTool !== 'compass') return;
      e.preventDefault(); e.stopPropagation();
      const targetId = e.currentTarget.id;
      if (targetId === 'compassPivot') compass.dragTarget = 'pivot';
      else if (targetId === 'pencilTip') compass.dragTarget = 'radius';
      else if (targetId === 'pencilDrawHandle') {
        compass.dragTarget = 'draw'; compass.centerDrawn = false;
        ctx.beginPath(); ctx.strokeStyle = currentColor; ctx.lineWidth = (currentColor === 'white') ? 20 : 2; 
        ctx.moveTo(compass.pivotX + compass.radius * Math.cos(compass.angle), compass.pivotY + compass.radius * Math.sin(compass.angle));
      }
      compass.isDragging = true;
      document.addEventListener('mousemove', dragCompass);
      document.addEventListener('touchmove', dragCompass, {passive: false});
      document.addEventListener('mouseup', endCompassDrag);
      document.addEventListener('touchend', endCompassDrag);
    }

    function dragCompass(e) {
      if (!compass.isDragging) return;
      e.preventDefault();
      const pos = getEventPos(e);

      if (compass.dragTarget === 'pivot') {
        compass.pivotX = pos.x; compass.pivotY = pos.y;
      } else if (compass.dragTarget === 'radius') {
        const dx = pos.x - compass.pivotX, dy = pos.y - compass.pivotY;
        if (compass.locked) { compass.angle = Math.atan2(dy, dx); }
        else {
          const newRadius = Math.sqrt(dx*dx + dy*dy);
          if (newRadius > 20) { compass.radius = newRadius; compass.angle = Math.atan2(dy, dx); }
        }
      } else if (compass.dragTarget === 'draw') {
        if (!compass.centerDrawn) { drawPoint(compass.pivotX, compass.pivotY, 'red'); compass.centerDrawn = true; ctx.beginPath(); ctx.strokeStyle = currentColor; ctx.lineWidth = (currentColor === 'white') ? 20 : 2; }
        const dx = pos.x - compass.pivotX, dy = pos.y - compass.pivotY;
        const newAngle = Math.atan2(dy, dx);
        let diff = newAngle - compass.angle;
        while (diff <= -Math.PI) diff += 2 * Math.PI; while (diff > Math.PI) diff -= 2 * Math.PI;
        ctx.beginPath(); ctx.strokeStyle = currentColor; ctx.lineWidth = (currentColor === 'white') ? 20 : 2;
        ctx.arc(compass.pivotX, compass.pivotY, compass.radius, compass.angle, newAngle, diff < 0);
        ctx.stroke();
        compass.angle = newAngle;
      }
      updateCompassUI();
    }

    function endCompassDrag(e) {
      if (compass.isDragging) {
        if (compass.dragTarget === 'draw') { saveState(); compass.locked = true; updateLockUI(); }
        compass.isDragging = false; compass.dragTarget = null;
        document.removeEventListener('mousemove', dragCompass);
        document.removeEventListener('touchmove', dragCompass);
        document.removeEventListener('mouseup', endCompassDrag);
        document.removeEventListener('touchend', endCompassDrag);
      }
    }
     
    // === â˜…åˆ†åº¦å™¨ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç† ===
    function startProtractorDrag(e) {
       if (currentTool !== 'protractor') return;
       e.preventDefault(); e.stopPropagation();
       
       const targetId = e.target.id;
       if (targetId === 'protractorRotateHandle') {
          protractor.dragTarget = 'rotate';
       } else {
          protractor.dragTarget = 'move';
       }
       protractor.isDragging = true;
       
       document.addEventListener('mousemove', dragProtractor);
       document.addEventListener('touchmove', dragProtractor, {passive: false});
       document.addEventListener('mouseup', endProtractorDrag);
       document.addEventListener('touchend', endProtractorDrag);
    }
     
    function dragProtractor(e) {
       if (!protractor.isDragging) return;
       e.preventDefault();
       const pos = getEventPos(e);
       
       if (protractor.dragTarget === 'move') {
          // ä¸‹ç«¯ä¸­å¤®ãŒ (x, y) ãªã®ã§ã€ãƒã‚¦ã‚¹ä½ç½®ã«åˆã‚ã›ã‚‹
          protractor.x = pos.x;
          protractor.y = pos.y;
       } else if (protractor.dragTarget === 'rotate') {
          // ä¸­å¿ƒ(x,y)ã‹ã‚‰ãƒã‚¦ã‚¹ä½ç½®ã¸ã®è§’åº¦
          const dx = pos.x - protractor.x;
          const dy = pos.y - protractor.y;
          protractor.angle = Math.atan2(dy, dx);
       }
       updateProtractorUI();
    }
     
    function endProtractorDrag() {
       if (protractor.isDragging) {
          protractor.isDragging = false;
          protractor.dragTarget = null;
          document.removeEventListener('mousemove', dragProtractor);
          document.removeEventListener('touchmove', dragProtractor);
          document.removeEventListener('mouseup', endProtractorDrag);
          document.removeEventListener('touchend', endProtractorDrag);
       }
    }

    function addToolListeners() {
      compassPivot.addEventListener('mousedown', startCompassDrag);
      compassPivot.addEventListener('touchstart', startCompassDrag, {passive: false});
      pencilTip.addEventListener('mousedown', startCompassDrag);
      pencilTip.addEventListener('touchstart', startCompassDrag, {passive: false});
      pencilDrawHandle.addEventListener('mousedown', startCompassDrag);
      pencilDrawHandle.addEventListener('touchstart', startCompassDrag, {passive: false});
       
      // â˜…åˆ†åº¦å™¨ãƒªã‚¹ãƒŠãƒ¼
      protractorBody.addEventListener('mousedown', startProtractorDrag);
      protractorBody.addEventListener('touchstart', startProtractorDrag, {passive: false});
       
      drawingArea.addEventListener('mousedown', handleStart);
      drawingArea.addEventListener('touchstart', handleStart, {passive: false});
      window.addEventListener('mousemove', handleMove); 
      window.addEventListener('touchmove', handleMove, {passive: false});
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchend', handleEnd);
    }

    function handleStart(e) {
      if (e.target.classList.contains('view-slider')) return;
      if (currentTool === 'protractor') return; 
       
      if (e.touches && e.touches.length === 2) {
        isPanning = true;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialPinchDist = Math.hypot(dx, dy);
        initialScale = view.scale;
        
        const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        startPan = { x: cx - view.x, y: cy - view.y };
        return;
      }
       
      if (currentTool === 'compass') return;
      if (!drawingArea.contains(e.target)) return;

      e.preventDefault(); 
      const pos = getEventPos(e);
       
      if (currentTool === 'moving_point') {
        if (!isMovingPointSet) {
           movingPoints.push({x: pos.x, y: pos.y});
           drawMovingPoints();
        } else {
           for(let i=0; i<movingPoints.length; i++) {
              const dx = pos.x - movingPoints[i].x;
              const dy = pos.y - movingPoints[i].y;
              if (dx*dx + dy*dy < 400) { 
                 dragMovingPointIndex = i;
                 break;
              }
           }
        }
      }
      else if (currentTool === 'point') { 
        drawPoint(pos.x, pos.y); saveState(); 
      }
      else if (currentTool === 'freehand' || currentTool === 'eraser') { 
        isDrawing = true; 
        ctx.beginPath(); 
        ctx.moveTo(pos.x, pos.y); 
        ctx.strokeStyle = (currentTool === 'eraser') ? 'white' : currentColor; 
        ctx.lineWidth = (currentTool === 'eraser') ? 20 : 2; 
        ctx.lineCap = 'round'; 
      }
      else if (currentTool === 'line' || currentTool === 'ruler') {
        if (!lineStartPoint) { lineStartPoint = pos; drawPoint(pos.x, pos.y, 'red'); }
        else { 
          const type = (currentTool === 'ruler') ? 'line' : 'segment';
          drawLine(lineStartPoint.x, lineStartPoint.y, pos.x, pos.y, type);
          lineStartPoint = null; saveState();
        }
      }
    }
     
    function drawMovingPoints() {
       overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
       _drawMovingOverlay();
    }
     
    function _drawMovingOverlay() {
       if (movingPoints.length === 0) return;
       
       overlayCtx.lineWidth = 2;
       overlayCtx.strokeStyle = "black";
       
       if (movingPoints.length > 1) {
         overlayCtx.beginPath();
         overlayCtx.moveTo(movingPoints[0].x, movingPoints[0].y);
         for(let i=1; i<movingPoints.length; i++) {
            overlayCtx.lineTo(movingPoints[i].x, movingPoints[i].y);
         }
         if (movingPoints.length >= 3) {
            overlayCtx.closePath();
            if (isMovingFillMode) {
               overlayCtx.fillStyle = "rgba(220, 53, 69, 0.2)"; 
               overlayCtx.fill();
            }
         }
         overlayCtx.stroke();
       }
       
       for(let i=0; i<movingPoints.length; i++) {
          drawSingleMovingPoint(movingPoints[i].x, movingPoints[i].y);
       }
    }
     
    function drawSingleMovingPoint(x, y) {
      overlayCtx.fillStyle = "#dc3545"; 
      overlayCtx.beginPath(); overlayCtx.arc(x, y, 3, 0, Math.PI * 2); overlayCtx.fill();
      overlayCtx.strokeStyle = "black"; overlayCtx.lineWidth = 1;
      overlayCtx.beginPath(); overlayCtx.arc(x, y, 6, 0, Math.PI * 2); overlayCtx.stroke();
    }

    function handleMove(e) {
      if (e.touches && e.touches.length === 2 && isPanning) {
         e.preventDefault();
         const dx = e.touches[0].clientX - e.touches[1].clientX;
         const dy = e.touches[0].clientY - e.touches[1].clientY;
         const currentDist = Math.hypot(dx, dy);
         if (initialPinchDist > 0) {
           const newScale = initialScale * (currentDist / initialPinchDist);
           if (newScale >= 0.5 && newScale <= 5.0) { view.scale = newScale; }
         }
         const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
         const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
         view.x = cx - startPan.x; view.y = cy - startPan.y;
         updateTransform();
         return;
      }

      if (currentTool === 'compass') return;
      if (currentTool === 'protractor') return; 
       
      if (currentTool === 'moving_point' && dragMovingPointIndex !== -1) {
         e.preventDefault();
         const pos = getEventPos(e);
         movingPoints[dragMovingPointIndex] = {x: pos.x, y: pos.y};
         drawMovingPoints();
         return;
      }

      if (!isDrawing && !lineStartPoint) return;
      if (e.touches && e.touches.length > 1) return;

      e.preventDefault(); 
      const pos = getEventPos(e);
      if ((currentTool === 'freehand' || currentTool === 'eraser') && isDrawing) { ctx.lineTo(pos.x, pos.y); ctx.stroke(); }
    }

    function handleEnd(e) {
      isPanning = false;
      dragMovingPointIndex = -1; 
      if ((currentTool === 'freehand' || currentTool === 'eraser') && isDrawing) { isDrawing = false; saveState(); }
    }

    function drawPoint(x, y, color = currentColor, radius = 3) { 
      ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
    }

    function drawLine(x1, y1, x2, y2, type) {
      ctx.strokeStyle = currentColor; 
      ctx.lineWidth = 2; ctx.beginPath();
      if (type === 'segment') { ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); }
      else { const ep = getExtendedLine(x1, y1, x2, y2); ctx.moveTo(ep.x1, ep.y1); ctx.lineTo(ep.x2, ep.y2); }
      ctx.stroke(); drawPoint(x1, y1); drawPoint(x2, y2);
    }

    function getExtendedLine(x1, y1, x2, y2) {
      const w = canvas.width; const h = canvas.height;
      if (x1 === x2) return { x1: x1, y1: 0, x2: x1, y2: h };
      if (y1 === y2) return { x1: 0, y1: y1, x2: w, y2: y1 };
      const m = (y2 - y1) / (x2 - x1); const b = y1 - m * x1;
      const pts = [];
      let y0 = b; if (y0 >= 0 && y0 <= h) pts.push({x:0, y:y0});
      let yw = m * w + b; if (yw >= 0 && yw <= h) pts.push({x:w, y:yw});
      let x0 = -b / m; if (x0 >= 0 && x0 <= w) pts.push({x:x0, y:0});
      let xh = (h - b) / m; if (xh >= 0 && xh <= w) pts.push({x:xh, y:h});
      if (pts.length >= 2) return { x1: pts[0].x, y1: pts[0].y, x2: pts[pts.length-1].x, y2: pts[pts.length-1].y };
      return { x1: x1, y1: y1, x2: x2, y2: y2 }; 
    }
    
    /* --- JS END --- */
  </script>

</body>
</html>
  
